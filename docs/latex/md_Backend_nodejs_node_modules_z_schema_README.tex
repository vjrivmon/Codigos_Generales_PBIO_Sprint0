\href{http://badge.fury.io/js/z-schema}{\texttt{ }} \href{http://badge.fury.io/bo/z-schema}{\texttt{ }} \href{https://travis-ci.org/zaggino/z-schema}{\texttt{ }} \href{https://coveralls.io/r/zaggino/z-schema}{\texttt{ }}

\href{https://greenkeeper.io/}{\texttt{ }} \href{https://david-dm.org/zaggino/z-schema}{\texttt{ }} \href{https://david-dm.org/zaggino/z-schema?type=dev}{\texttt{ }} \href{https://david-dm.org/zaggino/z-schema?type=optional}{\texttt{ }}

\href{https://nodei.co/npm/z-schema/}{\texttt{ }}


\begin{DoxyItemize}
\item version 3.\+0 runs also in the browsers now, run tests yourself \href{https://rawgit.com/zaggino/z-schema/master/test/SpecRunner.html}{\texttt{ here}}
\end{DoxyItemize}\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3476}{}\doxysection{Topics}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3476}

\begin{DoxyItemize}
\item Usage
\item Features
\item Options
\item Benchmarks
\item Contributors
\end{DoxyItemize}\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3477}{}\doxysection{Usage}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3477}
Validator will try to perform sync validation when possible for speed, but supports async callbacks when they are necessary.\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3478}{}\doxysubsection{Development\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3478}
These repository has several submodules and should be cloned as follows\+: \texorpdfstring{$>$}{>}git clone {\bfseries{--recursive}} \href{https://github.com/zaggino/z-schema.git}{\texttt{ https\+://github.\+com/zaggino/z-\/schema.\+git}}\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3479}{}\doxysubsection{CLI\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3479}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm install -\/-\/global z-\/schema}
\DoxyCodeLine{z-\/schema -\/-\/help}
\DoxyCodeLine{z-\/schema mySchema.json}
\DoxyCodeLine{z-\/schema mySchema.json myJson.json}
\DoxyCodeLine{z-\/schema -\/-\/strictMode mySchema.json myJson.json}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3480}{}\doxysubsection{Node\+JS\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3480}

\begin{DoxyCode}{0}
\DoxyCodeLine{var ZSchema = require("{}z-\/schema"{});}
\DoxyCodeLine{var options = ... // see below for possible option values}
\DoxyCodeLine{var validator = new ZSchema(options);}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3481}{}\doxysubsection{Sync mode\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3481}

\begin{DoxyCode}{0}
\DoxyCodeLine{var valid = validator.validate(json, schema);}
\DoxyCodeLine{// this will return a native error object with name and message}
\DoxyCodeLine{var error = validator.getLastError();}
\DoxyCodeLine{// this will return an array of validation errors encountered}
\DoxyCodeLine{var errors = validator.getLastErrors();}
\DoxyCodeLine{...}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3482}{}\doxysubsection{Async mode\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3482}

\begin{DoxyCode}{0}
\DoxyCodeLine{validator.validate(json, schema, function (err, valid) \{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3483}{}\doxysubsection{Browser\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3483}

\begin{DoxyCode}{0}
\DoxyCodeLine{<script type="{}text/javascript"{} src="{}../dist/ZSchema-\/browser-\/min.js"{}></script>}
\DoxyCodeLine{<script type="{}text/javascript"{}>}
\DoxyCodeLine{    var validator = new ZSchema();}
\DoxyCodeLine{    var valid = validator.validate("{}string"{}, \{ "{}type"{}: "{}string"{} \});}
\DoxyCodeLine{    console.log(valid);}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3484}{}\doxysubsection{Remote references and schemas\+:}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3484}
In case you have some remote references in your schemas, you have to download those schemas before using validator. Otherwise you\textquotesingle{}ll get {\ttfamily UNRESOLVABLE\+\_\+\+REFERENCE} error when trying to compile a schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema();}
\DoxyCodeLine{var json = \{\};}
\DoxyCodeLine{var schema = \{ "{}\$ref"{}: "{}http://json-\/schema.org/draft-\/04/schema\#"{} \};}
\DoxyCodeLine{}
\DoxyCodeLine{var valid = validator.validate(json, schema);}
\DoxyCodeLine{var errors = validator.getLastErrors();}
\DoxyCodeLine{// valid === false}
\DoxyCodeLine{// errors.length === 1}
\DoxyCodeLine{// errors[0].code === "{}UNRESOLVABLE\_REFERENCE"{}}
\DoxyCodeLine{}
\DoxyCodeLine{var requiredUrl = "{}http://json-\/schema.org/draft-\/04/schema"{};}
\DoxyCodeLine{request(requiredUrl, function (error, response, body) \{}
\DoxyCodeLine{}
\DoxyCodeLine{    validator.setRemoteReference(requiredUrl, JSON.parse(body));}
\DoxyCodeLine{}
\DoxyCodeLine{    var valid = validator.validate(json, schema);}
\DoxyCodeLine{    var errors = validator.getLastErrors();}
\DoxyCodeLine{    // valid === true}
\DoxyCodeLine{    // errors === undefined}
\DoxyCodeLine{}
\DoxyCodeLine{\}}

\end{DoxyCode}


If you\textquotesingle{}re able to load schemas synchronously, you can use {\ttfamily ZSchema.\+set\+Schema\+Reader} feature\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ZSchema.setSchemaReader(function (uri) \{}
\DoxyCodeLine{    var someFilename = path.resolve(\_\_dirname, "{}.."{}, "{}schemas"{}, uri + "{}.json"{});}
\DoxyCodeLine{    return JSON.parse(fs.readFileSync(someFilename, "{}utf8"{}));}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3485}{}\doxysection{Features}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3485}

\begin{DoxyItemize}
\item Validate against subschema
\item Compile arrays of schemas and use references between them
\item Register a custom format
\item Automatic downloading of remote schemas
\item Prefill default values to object using format
\item Define a custom timeout for all async operations
\item Disallow validation of empty arrays as arrays
\item Disallow validation of empty strings as strings
\item Disallow schemas that don\textquotesingle{}t have a type specified
\item Disallow schemas that contain unrecognized keywords and are not validated by parent schemas
\item Assume additional\+Items/additional\+Properties are defined in schemas as false
\item Force additional\+Items/additional\+Properties to be defined in schemas
\item Force items to be defined in array type schemas
\item Force min\+Items to be defined in array type schemas
\item Force max\+Items to be defined in array type schemas
\item Force min\+Length to be defined in string type schemas
\item Force max\+Length to be defined in string type schemas
\item Force properties or pattern\+Properties to be defined in object type schemas
\item Ignore remote references to schemas that are not cached or resolvable
\item Ignore case mismatch when validating enum values
\item Only allow strictly absolute URIs to be used in schemas
\item Turn on z-\/schema strict mode
\item Set validator to collect as many errors as possible
\item Report paths in errors as arrays so they can be processed easier
\end{DoxyItemize}\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3486}{}\doxysubsection{Validate against subschema}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3486}
In case you don\textquotesingle{}t want to split your schema into multiple schemas using reference for any reason, you can use option schema\+Path when validating\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var valid = validator.validate(cars, schema, \{ schemaPath: "{}definitions.car.definitions.cars"{} \});}

\end{DoxyCode}


See more details in the \href{/test/spec/schemaPathSpec.js}{\texttt{ test}}.\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3487}{}\doxysubsection{Compile arrays of schemas and use references between them}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3487}
You can use validator to compile an array of schemas that have references between them and then validate against one of those schemas\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var schemas = [}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        id: "{}personDetails"{},}
\DoxyCodeLine{        type: "{}object"{},}
\DoxyCodeLine{        properties: \{}
\DoxyCodeLine{            firstName: \{ type: "{}string"{} \},}
\DoxyCodeLine{            lastName: \{ type: "{}string"{} \}}
\DoxyCodeLine{        \},}
\DoxyCodeLine{        required: ["{}firstName"{}, "{}lastName"{}]}
\DoxyCodeLine{    \},}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        id: "{}addressDetails"{},}
\DoxyCodeLine{        type: "{}object"{},}
\DoxyCodeLine{        properties: \{}
\DoxyCodeLine{            street: \{ type: "{}string"{} \},}
\DoxyCodeLine{            city: \{ type: "{}string"{} \}}
\DoxyCodeLine{        \},}
\DoxyCodeLine{        required: ["{}street"{}, "{}city"{}]}
\DoxyCodeLine{    \},}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        id: "{}personWithAddress"{},}
\DoxyCodeLine{        allOf: [}
\DoxyCodeLine{            \{ \$ref: "{}personDetails"{} \},}
\DoxyCodeLine{            \{ \$ref: "{}addressDetails"{} \}}
\DoxyCodeLine{        ]}
\DoxyCodeLine{    \}}
\DoxyCodeLine{];}
\DoxyCodeLine{}
\DoxyCodeLine{var data = \{}
\DoxyCodeLine{    firstName: "{}Martin"{},}
\DoxyCodeLine{    lastName: "{}Zagora"{},}
\DoxyCodeLine{    street: "{}George St"{},}
\DoxyCodeLine{    city: "{}Sydney"{}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{var validator = new ZSchema();}
\DoxyCodeLine{}
\DoxyCodeLine{// compile \& validate schemas first, z-\/schema will automatically handle array}
\DoxyCodeLine{var allSchemasValid = validator.validateSchema(schemas);}
\DoxyCodeLine{// allSchemasValid === true}
\DoxyCodeLine{}
\DoxyCodeLine{// now validate our data against the last schema}
\DoxyCodeLine{var valid = validator.validate(data, schemas[2]);}
\DoxyCodeLine{// valid === true}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3488}{}\doxysubsection{Register a custom format}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3488}
You can register any format of your own. Your sync validator function should always respond with a boolean\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ZSchema.registerFormat("{}xstring"{}, function (str) \{}
\DoxyCodeLine{    return str === "{}xxx"{};}
\DoxyCodeLine{\});}

\end{DoxyCode}


Async format validators are also supported, they should accept two arguments, value and a callback to which they need to respond\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ZSchema.registerFormat("{}xstring"{}, function (str, callback) \{}
\DoxyCodeLine{    setTimeout(function () \{}
\DoxyCodeLine{        callback(str === "{}xxx"{});}
\DoxyCodeLine{    \}, 1);}
\DoxyCodeLine{\});}

\end{DoxyCode}
 \hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3489}{}\doxysubsection{Helper method to check the formats that have been registered}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3489}

\begin{DoxyCode}{0}
\DoxyCodeLine{var registeredFormats = ZSchema.getRegisteredFormats();}
\DoxyCodeLine{//registeredFormats will now contain an array of all formats that have been registered with z-\/schema}

\end{DoxyCode}
 \hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3490}{}\doxysubsection{Automatic downloading of remote schemas}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3490}
Automatic downloading of remote schemas was removed from version {\ttfamily 3.\+x} but is still possible with a bit of extra code, see \href{test/spec/AutomaticSchemaLoadingSpec.js}{\texttt{ this test}} for more information on this.\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3491}{}\doxysubsection{Prefill default values to object using format}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3491}
Using format, you can pre-\/fill values of your choosing into the objects like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ZSchema.registerFormat("{}fillHello"{}, function (obj) \{}
\DoxyCodeLine{    obj.hello = "{}world"{};}
\DoxyCodeLine{    return true;}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{var data = \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{var schema = \{}
\DoxyCodeLine{    "{}type"{}: "{}object"{},}
\DoxyCodeLine{    "{}format"{}: "{}fillHello"{}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{validator.validate(data, schema);}
\DoxyCodeLine{// data.hello === "{}world"{}}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3492}{}\doxysection{Options}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3492}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3493}{}\doxysubsection{async\+Timeout}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3493}
Defines a time limit, which should be used when waiting for async tasks like async format validators to perform their validation, before the validation fails with an {\ttfamily ASYNC\+\_\+\+TIMEOUT} error.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    asyncTimeout: 2000}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3494}{}\doxysubsection{no\+Empty\+Arrays}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3494}
When true, validator will assume that minimum count of items in any {\ttfamily array} is 1, except when {\ttfamily min\+Items\+: 0} is explicitly defined.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    noEmptyArrays: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3495}{}\doxysubsection{no\+Empty\+Strings}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3495}
When true, validator will assume that minimum length of any string to pass type {\ttfamily string} validation is 1, except when {\ttfamily min\+Length\+: 0} is explicitly defined.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    noEmptyStrings: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3496}{}\doxysubsection{no\+Typeless}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3496}
When true, validator will fail validation for schemas that don\textquotesingle{}t specify a {\ttfamily type} of object that they expect.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    noTypeless: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3497}{}\doxysubsection{no\+Extra\+Keywords}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3497}
When true, validator will fail for schemas that use keywords not defined in JSON Schema specification and doesn\textquotesingle{}t provide a parent schema in {\ttfamily \$schema} property to validate the schema.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    noExtraKeywords: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3498}{}\doxysubsection{assume\+Additional}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3498}
When true, validator assumes that additional\+Items/additional\+Properties are defined as false so you don\textquotesingle{}t have to manually fix all your schemas.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    assumeAdditional: true}
\DoxyCodeLine{\});}

\end{DoxyCode}


When an array, validator assumes that additional\+Items/additional\+Properties are defined as false, but allows some properties to pass.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    assumeAdditional: ["{}\$ref"{}]}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3499}{}\doxysubsection{force\+Additional}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3499}
When true, validator doesn\textquotesingle{}t validate schemas where additional\+Items/additional\+Properties should be defined to either true or false.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceAdditional: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3500}{}\doxysubsection{force\+Items}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3500}
When true, validator doesn\textquotesingle{}t validate schemas where {\ttfamily items} are not defined for {\ttfamily array} type schemas. This is to avoid passing anything through an array definition.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceItems: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3501}{}\doxysubsection{force\+Min\+Items}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3501}
When true, validator doesn\textquotesingle{}t validate schemas where {\ttfamily min\+Items} is not defined for {\ttfamily array} type schemas. This is to avoid passing zero-\/length arrays which application doesn\textquotesingle{}t expect to handle.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceMinItems: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3502}{}\doxysubsection{force\+Max\+Items}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3502}
When true, validator doesn\textquotesingle{}t validate schemas where {\ttfamily max\+Items} is not defined for {\ttfamily array} type schemas. This is to avoid passing arrays with unlimited count of elements which application doesn\textquotesingle{}t expect to handle.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceMaxItems: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3503}{}\doxysubsection{force\+Min\+Length}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3503}
When true, validator doesn\textquotesingle{}t validate schemas where {\ttfamily min\+Length} is not defined for {\ttfamily string} type schemas. This is to avoid passing zero-\/length strings which application doesn\textquotesingle{}t expect to handle.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceMinLength: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3504}{}\doxysubsection{force\+Max\+Length}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3504}
When true, validator doesn\textquotesingle{}t validate schemas where {\ttfamily max\+Length} is not defined for {\ttfamily string} type schemas. This is to avoid passing extremly large strings which application doesn\textquotesingle{}t expect to handle.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceMaxLength: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3505}{}\doxysubsection{force\+Properties}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3505}
When true, validator doesn\textquotesingle{}t validate schemas where {\ttfamily properties} or {\ttfamily pattern\+Properties} is not defined for {\ttfamily object} type schemas. This is to avoid having objects with unexpected properties in application.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    forceProperties: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3506}{}\doxysubsection{ignore\+Unresolvable\+References}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3506}
When true, validator doesn\textquotesingle{}t end with error when a remote reference is unreachable. {\bfseries{This setting is not recommended in production outside of testing.}}


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    ignoreUnresolvableReferences: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
 \hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3507}{}\doxysubsection{enum\+Case\+Insensitive\+Comparison}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3507}
When true, validator will return a {\ttfamily ENUM\+\_\+\+CASE\+\_\+\+MISMATCH} when the enum values mismatch only in case.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    enumCaseInsensitiveComparison: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3508}{}\doxysubsection{strict\+Uris}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3508}
When true, all strings of format {\ttfamily uri} must be an absolute URIs and not only URI references. See more details in \href{https://github.com/zaggino/z-schema/issues/18}{\texttt{ this issue}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    strictUris: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3509}{}\doxysubsection{strict\+Mode}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3509}
Strict mode of z-\/schema is currently equal to the following\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{if (this.options.strictMode === true) \{}
\DoxyCodeLine{    this.options.forceAdditional  = true;}
\DoxyCodeLine{    this.options.forceItems       = true;}
\DoxyCodeLine{    this.options.forceMaxLength   = true;}
\DoxyCodeLine{    this.options.forceProperties  = true;}
\DoxyCodeLine{    this.options.noExtraKeywords  = true;}
\DoxyCodeLine{    this.options.noTypeless       = true;}
\DoxyCodeLine{    this.options.noEmptyStrings   = true;}
\DoxyCodeLine{    this.options.noEmptyArrays    = true;}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    strictMode: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3510}{}\doxysubsection{break\+On\+First\+Error}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3510}
default\+: {\ttfamily false}~\newline
 When true, will stop validation after the first error is found\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    breakOnFirstError: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3511}{}\doxysubsection{report\+Path\+As\+Array}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3511}
Report error paths as an array of path segments instead of a string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    reportPathAsArray: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3512}{}\doxysubsection{ignore\+Unknown\+Formats}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3512}
By default, z-\/schema reports all unknown formats, formats not defined by JSON Schema and not registered using {\ttfamily ZSchema.\+register\+Format}, as an error. But the \href{http://json-schema.org/latest/json-schema-validation.html\#anchor106}{\texttt{ JSON Schema specification}} says that validator implementations $\ast$\char`\"{}they SHOULD offer an option to disable validation\char`\"{}$\ast$ for {\ttfamily format}. That being said, setting this option to {\ttfamily true} will disable treating unknown formats as errlrs


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    ignoreUnknownFormats: true}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3513}{}\doxysubsection{include\+Errors}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3513}
By default, z-\/schema reports all errors. If interested only in a subset of the errors, passing the option {\ttfamily include\+Errors} to {\ttfamily validate} will perform validations only for those errors.


\begin{DoxyCode}{0}
\DoxyCodeLine{var validator = new ZSchema();}
\DoxyCodeLine{// will only execute validation for "{}INVALID\_TYPE"{} error.}
\DoxyCodeLine{validator.validate(json, schema, \{includeErrors: ["{}INVALID\_TYPE"{}]\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3514}{}\doxysubsection{custom\+Validator}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3514}
{\bfseries{Warning}}\+: Use only if know what you are doing. Always consider using custom format before using this option.

Register function to be called as part of validation process on every subshema encounter during validation.

Let\textquotesingle{}s make a real-\/life example with this feature. Imagine you have number of transactions\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{    "{}fromId"{}: 1034834329,}
\DoxyCodeLine{    "{}toId"{}: 1034834543,}
\DoxyCodeLine{    "{}amount"{}: 200}
\DoxyCodeLine{\}}

\end{DoxyCode}
 So you write the schema\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{    "{}type"{}: "{}object"{},}
\DoxyCodeLine{    "{}properties"{}: \{}
\DoxyCodeLine{        "{}fromId"{}: \{}
\DoxyCodeLine{            "{}type"{}: "{}integer"{}}
\DoxyCodeLine{        \},}
\DoxyCodeLine{        "{}toId"{}: \{}
\DoxyCodeLine{            "{}type"{}: "{}integer"{}}
\DoxyCodeLine{        \},}
\DoxyCodeLine{        "{}amount"{}: \{}
\DoxyCodeLine{            "{}type"{}: "{}number"{}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 But how to check that {\ttfamily from\+Id} and {\ttfamily to\+Id} are never equal. In JSON Schema Draft4 there is no possibility to do this. Actually, it\textquotesingle{}s easy to just write validation code for such simple payloads. But what if you have to do the same check for many objects in different places of JSON payload. One solution is to add custom keyword {\ttfamily unique\+Properties} with array of property names as a value. So in our schema we would need to add\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{"{}uniqueProperties"{}: [}
\DoxyCodeLine{    "{}fromId"{},}
\DoxyCodeLine{    "{}toId"{}}
\DoxyCodeLine{]}

\end{DoxyCode}
 To teach {\ttfamily z-\/schema} about this new keyword we need to write handler for it\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{function customValidatorFn(report, schema, json) \{}
\DoxyCodeLine{    // check if our custom property is present}
\DoxyCodeLine{    if (Array.isArray(schema.uniqueProperties)) \{}
\DoxyCodeLine{        var seenValues = [];}
\DoxyCodeLine{        schema.uniqueProperties.forEach(function (prop) \{}
\DoxyCodeLine{            var value = json[prop];}
\DoxyCodeLine{            if (typeof value !== 'undefined') \{}
\DoxyCodeLine{                if (seenValues.indexOf(value) !== -\/1) \{}
\DoxyCodeLine{                    // report error back to z-\/schema core}
\DoxyCodeLine{                    report.addCustomError("{}NON\_UNIQUE\_PROPERTY\_VALUE"{},}
\DoxyCodeLine{                        "{}Property \(\backslash\)"{}\{0\}\(\backslash\)"{} has non-\/unique value: \{1\}"{},}
\DoxyCodeLine{                        [prop, value], null, schema.description);}
\DoxyCodeLine{                \}}
\DoxyCodeLine{                seenValues.push(value)}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{var validator = new ZSchema(\{}
\DoxyCodeLine{    // register our custom validator inside z-\/schema}
\DoxyCodeLine{    customValidator: customValidatorFn}
\DoxyCodeLine{\});}

\end{DoxyCode}
 Let\textquotesingle{}s test it\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var data = \{}
\DoxyCodeLine{    fromId: 1034834346,}
\DoxyCodeLine{    toId: 1034834346,}
\DoxyCodeLine{    amount: 50}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{validator.validate(data, schema);}
\DoxyCodeLine{console.log(validator.getLastErrors())}
\DoxyCodeLine{//[ \{ code: 'NON\_UNIQUE\_PROPERTY\_VALUE',}
\DoxyCodeLine{//    params: [ 'toId', 1034834346 ],}
\DoxyCodeLine{//    message: 'Property "{}toId"{} has non-\/unique value: 1034834346',}
\DoxyCodeLine{//    path: '\#/',}
\DoxyCodeLine{//    schemaId: undefined \} ]}

\end{DoxyCode}
 {\bfseries{Note\+:}} before creating your own keywords you should consider all compatibility issues.\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3515}{}\doxysection{Benchmarks}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3515}
So how does it compare to version 2.\+x and others?

{\bfseries{NOTE\+: these tests are purely orientational, they don\textquotesingle{}t consider extra features any of the validator may support and implement}}

\href{https://rawgithub.com/zaggino/z-schema/master/benchmark/results.html}{\texttt{ rawgithub.\+com/zaggino/z-\/schema/master/benchmark/results.html}}\hypertarget{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3516}{}\doxysection{Contributors}\label{md_Backend_nodejs_node_modules_z_schema_README_autotoc_md3516}
Thanks for contributing to\+:


\begin{DoxyItemize}
\item \href{https://github.com/whitlockjc}{\texttt{ Jeremy Whitlock}}
\item \href{https://github.com/oleksiyk}{\texttt{ Oleksiy Krivoshey}}
\end{DoxyItemize}

and to everyone submitting \href{https://github.com/zaggino/z-schema/issues}{\texttt{ issues}} on Git\+Hub 