\doxysection*{lru.\+min}



\href{https://www.npmjs.com/package/lru.min}{\texttt{ }} \href{https://www.npmjs.com/package/lru.min}{\texttt{ }} \href{https://app.codecov.io/gh/wellwelwel/lru.min}{\texttt{ }}~\newline
 \href{https://github.com/wellwelwel/lru.min/actions/workflows/ci_node.yml?query=branch\%3Amain}{\texttt{ }} \href{https://github.com/wellwelwel/lru.min/actions/workflows/ci_bun.yml?query=branch\%3Amain}{\texttt{ }} \href{https://github.com/wellwelwel/lru.min/actions/workflows/ci_deno.yml?query=branch\%3Amain}{\texttt{ }}

🔥 An extremely fast and efficient {\bfseries{\href{https://en.m.wikipedia.org/wiki/Cache_replacement_policies\#Least_Recently_Used_.28LRU.29}{\texttt{ LRU}} Cache}} for {\bfseries{Java\+Script}} ({\bfseries{Browser}} compatible) — {\bfseries{6.\+8\+KB}}.

\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1726}{}\doxysubsection{Why another LRU?}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1726}

\begin{DoxyItemize}
\item 🎖️ {\bfseries{lru.\+min}} is fully compatible with both {\bfseries{Node.\+js}} \+\_\+(8+)\+\_\+, {\bfseries{Bun}}, {\bfseries{Deno}} and, browser environments. All of this, while maintaining the same high performance \href{https://github.com/wellwelwel/lru.min?tab=readme-ov-file\#performance}{\texttt{ \+\_\+(and a little more)\+\_\+}} as the most popular {\bfseries{LRU}} packages.
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1728}{}\doxysubsection{Install}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1728}

\begin{DoxyCode}{0}
\DoxyCodeLine{\# Node.js}
\DoxyCodeLine{npm i lru.min}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\# Bun}
\DoxyCodeLine{bun add lru.min}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\# Deno}
\DoxyCodeLine{deno add npm:lru.min}

\end{DoxyCode}


\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1730}{}\doxysubsection{Usage}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1730}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1731}{}\doxysubsubsection{Quickstart}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1731}

\begin{DoxyCode}{0}
\DoxyCodeLine{import \{ createLRU \} from 'lru.min';}
\DoxyCodeLine{}
\DoxyCodeLine{const max = 2;}
\DoxyCodeLine{const onEviction = (key, value) => \{}
\DoxyCodeLine{  console.log(`Key "{}\$\{key\}"{} with value "{}\$\{value\}"{} has been evicted.`);}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const LRU = createLRU(\{}
\DoxyCodeLine{  max,}
\DoxyCodeLine{  onEviction,}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.set('A', 'My Value');}
\DoxyCodeLine{LRU.set('B', 'Other Value');}
\DoxyCodeLine{LRU.set('C', 'Another Value');}
\DoxyCodeLine{}
\DoxyCodeLine{// => Key "{}A"{} with value "{}My Value"{} has been evicted.}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.has('B');}
\DoxyCodeLine{LRU.get('B');}
\DoxyCodeLine{LRU.delete('B');}
\DoxyCodeLine{}
\DoxyCodeLine{// => Key "{}B"{} with value "{}Other Value"{} has been evicted.}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.peek('C');}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.clear(); // LRU.evict(max)}
\DoxyCodeLine{}
\DoxyCodeLine{// => Key "{}C"{} with value "{}Another Value"{} has been evicted.}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.set('D', "{}You're amazing 💛"{});}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.size; // 1}
\DoxyCodeLine{LRU.max; // 2}
\DoxyCodeLine{LRU.available; // 1}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.resize(10);}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.size; // 1}
\DoxyCodeLine{LRU.max; // 10}
\DoxyCodeLine{LRU.available; // 9}

\end{DoxyCode}


\begin{quote}
For {\itshape up-\/to-\/date} documentation, always follow the \href{https://github.com/wellwelwel/lru.min?tab=readme-ov-file\#readme}{\texttt{ {\bfseries{README.\+md}}}} in the {\bfseries{Git\+Hub}} repository. \end{quote}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1732}{}\doxysubsubsection{Import}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1732}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1733}{}\doxyparagraph{ES Modules}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1733}

\begin{DoxyCode}{0}
\DoxyCodeLine{import \{ createLRU \} from 'lru.min';}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1734}{}\doxyparagraph{Common\+JS}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1734}

\begin{DoxyCode}{0}
\DoxyCodeLine{const \{ createLRU \} = require('lru.min');}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1735}{}\doxyparagraph{Browser}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1735}
\begin{quote}
Requires {\bfseries{ES6}}. \end{quote}

\begin{DoxyCode}{0}
\DoxyCodeLine{<script src="{}https://cdn.jsdelivr.net/npm/lru.min@1.x.x/browser/lru.min.js"{}></script>}

\end{DoxyCode}



\begin{DoxyItemize}
\item You can use tools such as \href{https://github.com/babel/babel}{\texttt{ {\bfseries{Babel}}}} to increase the compatibility rate.
\end{DoxyItemize}\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1736}{}\doxysubsubsection{Create a new LRU Cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1736}
\begin{quote}
Set maximum size when creating {\bfseries{LRU}}. \end{quote}

\begin{DoxyCode}{0}
\DoxyCodeLine{const LRU = createLRU(\{ max: 150\_000 \});}

\end{DoxyCode}


Also, you can set a callback for every deletion/eviction\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const LRU = createLRU(\{}
\DoxyCodeLine{  max: 150\_000,}
\DoxyCodeLine{  onEviction: (key, value) => \{}
\DoxyCodeLine{    // do something}
\DoxyCodeLine{  \},}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1737}{}\doxysubsubsection{Set a cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1737}
Adds a key-\/value pair to the cache. Updates the value if the key already exists


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.set('key', 'value');}

\end{DoxyCode}


\begin{quote}
{\ttfamily undefined} keys will simply be ignored. \end{quote}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1738}{}\doxysubsubsection{Get a cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1738}
Retrieves the value for a given key and moves the key to the most recent position.


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.get('key');}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1739}{}\doxysubsubsection{Peek a cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1739}
Retrieves the value for a given key without changing its position.


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.peek('key');}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1740}{}\doxysubsubsection{Check if a key exists}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1740}

\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.has('key');}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1741}{}\doxysubsubsection{Delete a cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1741}

\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.delete('key');}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1742}{}\doxysubsubsection{Evict from the oldest cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1742}
Evicts the specified number of the oldest items from the cache.


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.evict(1000);}

\end{DoxyCode}


\begin{quote}
\mbox{[}!\+TIP\mbox{]}


\begin{DoxyItemize}
\item Methods that perform eviction(s) when maximum size is reached\+: {\ttfamily set} and {\ttfamily resize}.
\item Methods that always perform eviction(s)\+: {\ttfamily delete}, {\ttfamily clear}, and {\ttfamily evict} itself. 
\end{DoxyItemize}\end{quote}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1743}{}\doxysubsubsection{Resize the cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1743}
Resizes the cache to a new maximum size, evicting items if necessary.


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.resize(50\_000);}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1744}{}\doxysubsubsection{Clear the cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1744}
Clears and disposes (if used) all key-\/value pairs from the cache.


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.clear();}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1745}{}\doxysubsubsection{Debugging}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1745}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1746}{}\doxyparagraph{Get the max size of the cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1746}

\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.max;}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1747}{}\doxyparagraph{Get the current size of the cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1747}

\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.size;}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1748}{}\doxyparagraph{Get the available slots in the cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1748}

\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.available;}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1749}{}\doxysubsubsection{Iterating the cache}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1749}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1750}{}\doxyparagraph{Get all keys}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1750}
Iterates over all keys in the cache, from most recent to least recent.


\begin{DoxyCode}{0}
\DoxyCodeLine{const keys = [...LRU.keys()];}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1751}{}\doxyparagraph{Get all values}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1751}
Iterates over all values in the cache, from most recent to least recent.


\begin{DoxyCode}{0}
\DoxyCodeLine{const values = [...LRU.values()];}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1752}{}\doxyparagraph{Get all entries}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1752}
Iterates over {\ttfamily \mbox{[}key, value\mbox{]}} pairs in the cache, from most recent to least recent.


\begin{DoxyCode}{0}
\DoxyCodeLine{const entries = [...LRU.entries()];}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1753}{}\doxyparagraph{Run a callback for each entry}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1753}
Iterates over each value-\/key pair in the cache, from most recent to least recent.


\begin{DoxyCode}{0}
\DoxyCodeLine{LRU.forEach((value, key) => \{}
\DoxyCodeLine{  // do something}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1754}{}\doxysubsubsection{Type\+Script}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1754}
You can set types for both keys and values. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import \{ createLRU \} from 'lru.min';}
\DoxyCodeLine{}
\DoxyCodeLine{type Key = number;}
\DoxyCodeLine{}
\DoxyCodeLine{type Value = \{}
\DoxyCodeLine{  name: string;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const LRU = createLRU<Key, Value>(\{ max: 1000 \});}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.set(1, \{ name: 'Peter' \});}
\DoxyCodeLine{LRU.set(2, \{ name: 'Mary' \});}

\end{DoxyCode}


Also\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{import \{ createLRU, type CacheOptions \} from 'lru.min';}
\DoxyCodeLine{}
\DoxyCodeLine{type Key = number;}
\DoxyCodeLine{}
\DoxyCodeLine{type Value = \{}
\DoxyCodeLine{  name: string;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{const options: CacheOptions<Key, Value> = \{}
\DoxyCodeLine{  max: 10,}
\DoxyCodeLine{  onEviction(key, value) \{}
\DoxyCodeLine{    console.log(key, value);}
\DoxyCodeLine{  \},}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{// No need to repeat the type params}
\DoxyCodeLine{const LRU = createLRU(options);}
\DoxyCodeLine{}
\DoxyCodeLine{LRU.set(1, \{ name: 'Peter' \});}
\DoxyCodeLine{LRU.set(2, \{ name: 'Mary' \});}

\end{DoxyCode}


\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1756}{}\doxysubsubsection{Performance}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1756}
The benchmark is performed by comparing {\ttfamily 1,000,000} runs through a maximum cache limit of {\ttfamily 100,000}, getting {\ttfamily 333,333} caches and deleting {\ttfamily 200,000} keys 10 consecutive times, clearing the cache every run.

\begin{quote}
-\/ \href{https://github.com/isaacs/node-lru-cache}{\texttt{ {\bfseries{lru-\/cache}}}} {\ttfamily v11.\+0.\+0}
\begin{DoxyItemize}
\item \href{https://github.com/sindresorhus/quick-lru}{\texttt{ {\bfseries{quick-\/lru}}}} {\ttfamily v7.\+0.\+0} 
\end{DoxyItemize}\end{quote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\# Time:}
\DoxyCodeLine{  lru.min:    240.45ms}
\DoxyCodeLine{  lru-\/cache:  258.32ms}
\DoxyCodeLine{  quick-\/lru:  279.89ms}
\DoxyCodeLine{}
\DoxyCodeLine{\# CPU:}
\DoxyCodeLine{  lru.min:    275558.30µs}
\DoxyCodeLine{  lru-\/cache:  306858.30µs}
\DoxyCodeLine{  quick-\/lru:  401318.80µs}

\end{DoxyCode}



\begin{DoxyItemize}
\item See detailed results and how the tests are run and compared in the \href{https://github.com/wellwelwel/lru.min/tree/main/benchmark}{\texttt{ {\bfseries{benchmark}}}} directory.
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1758}{}\doxysubsection{Security Policy}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1758}
\href{https://github.com/wellwelwel/lru.min/actions/workflows/ci_codeql.yml?query=branch\%3Amain}{\texttt{ }}

Please check the \href{https://github.com/wellwelwel/lru.min/blob/main/SECURITY.md}{\texttt{ {\bfseries{SECURITY.\+md}}}}.

\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1760}{}\doxysubsection{Contributing}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1760}
See the \href{https://github.com/wellwelwel/lru.min/blob/main/CONTRIBUTING.md}{\texttt{ {\bfseries{Contributing Guide}}}} and please follow our \href{https://github.com/wellwelwel/lru.min/blob/main/CODE_OF_CONDUCT.md}{\texttt{ {\bfseries{Code of Conduct}}}} 🚀

\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1762}{}\doxysubsection{Acknowledgements}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1762}
{\bfseries{lru.\+min}} is based and inspired on the architecture and code of both \href{https://github.com/isaacs/node-lru-cache}{\texttt{ {\bfseries{lru-\/cache}}}} and \href{https://github.com/sindresorhus/quick-lru}{\texttt{ {\bfseries{quick-\/lru}}}}, simplifying their core concepts for enhanced performance and compatibility.

For more comprehensive features such as {\bfseries{TTL}} support, consider using and supporting them 🤝


\begin{DoxyItemize}
\item The architecture is mostly based on \href{https://github.com/isaacs}{\texttt{ @isaacs}} — \href{https://github.com/isaacs/node-lru-cache/blob/8f51d75351cbb4ac819952eb8e9f95eda00ef800/src/index.ts}{\texttt{ {\bfseries{lru-\/cache}}}}.
\item Most of the methods names and its functionalities were inspired by \href{https://github.com/sindresorhus}{\texttt{ @sindresorhus}} — \href{https://github.com/sindresorhus/quick-lru/blob/a2262c65e1952539cb4d985a67c46363a780d234/index.js}{\texttt{ {\bfseries{quick-\/lru}}}}.
\item \href{https://github.com/wellwelwel/lru.min/graphs/contributors}{\texttt{ }}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1764}{}\doxyparagraph{What comes from $<$a href=\char`\"{}https\+://github.\+com/isaacs/node-\/lru-\/cache\char`\"{} $>$$<$strong$>$lru-\/cache$<$/strong$>$$<$/a$>$?}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1764}
Architecture\textquotesingle{}s essence\+:

\begin{quote}
{\itshape It\textquotesingle{}s not the same code, but majority based on \href{https://github.com/isaacs/node-lru-cache/blob/8f51d75351cbb4ac819952eb8e9f95eda00ef800/src/index.ts\#L1385-L1394}{\texttt{ this}}.} \end{quote}

\begin{DoxyCode}{0}
\DoxyCodeLine{let free: number[] = [];}
\DoxyCodeLine{}
\DoxyCodeLine{const keyMap: Map<Key, number> = new Map();}
\DoxyCodeLine{const keyList: (Key | undefined)[] = new Array(max).fill(undefined);}
\DoxyCodeLine{const valList: (Value | undefined)[] = new Array(max).fill(undefined);}
\DoxyCodeLine{const next: number[] = new Array(max).fill(0);}
\DoxyCodeLine{const prev: number[] = new Array(max).fill(0);}

\end{DoxyCode}


\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1766}{}\doxyparagraph{What comes from $<$a href=\char`\"{}https\+://github.\+com/sindresorhus/quick-\/lru\char`\"{} $>$$<$strong$>$quick-\/lru$<$/strong$>$$<$/a$>$?}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1766}
Name of methods and options \+\_\+(including their final functionality ideas)\+\_\+\+:


\begin{DoxyItemize}
\item {\ttfamily resize}
\item {\ttfamily peek}
\item {\ttfamily on\+Eviction}
\item {\ttfamily for\+Each}
\item {\ttfamily entries\+Descending} as {\ttfamily entries}
\end{DoxyItemize}

\DoxyHorRuler{0}
\hypertarget{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1768}{}\doxysubsection{License}\label{md_Backend_nodejs_node_modules_lru_min_README_autotoc_md1768}
{\bfseries{lru.\+min}} is under the \href{https://github.com/wellwelwel/lru.min/blob/main/LICENSE}{\texttt{ {\bfseries{MIT License}}}}.~\newline
 Copyright © 2024-\/present \href{https://github.com/wellwelwel}{\texttt{ Weslley Araújo}} and {\bfseries{lru.\+min}} \href{https://github.com/wellwelwel/lru.min/graphs/contributors}{\texttt{ contributors}}. 