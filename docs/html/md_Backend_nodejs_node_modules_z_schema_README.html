<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Códigos Generales Sprint 0 PBIO: z-schema validator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Códigos Generales Sprint 0 PBIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Buscar','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">z-schema validator </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a href="http://badge.fury.io/js/z-schema"><img src="https://badge.fury.io/js/z-schema.svg" alt="npm version" style="pointer-events: none;" class="inline"/></a> <a href="http://badge.fury.io/bo/z-schema"><img src="https://badge.fury.io/bo/z-schema.svg" alt="bower version" style="pointer-events: none;" class="inline"/></a> <a href="https://travis-ci.org/zaggino/z-schema"><img src="https://travis-ci.org/zaggino/z-schema.svg?branch=master" alt="build status" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/r/zaggino/z-schema"><img src="https://coveralls.io/repos/zaggino/z-schema/badge.svg" alt="coverage status" style="pointer-events: none;" class="inline"/></a></p>
<p ><a href="https://greenkeeper.io/"><img src="https://badges.greenkeeper.io/zaggino/z-schema.svg" alt="Greenkeeper badge" style="pointer-events: none;" class="inline"/></a> <a href="https://david-dm.org/zaggino/z-schema"><img src="https://david-dm.org/zaggino/z-schema/status.svg" alt="dependencies Status" style="pointer-events: none;" class="inline"/></a> <a href="https://david-dm.org/zaggino/z-schema?type=dev"><img src="https://david-dm.org/zaggino/z-schema/dev-status.svg" alt="devDependencies Status" style="pointer-events: none;" class="inline"/></a> <a href="https://david-dm.org/zaggino/z-schema?type=optional"><img src="https://david-dm.org/zaggino/z-schema/optional-status.svg" alt="optionalDependencies Status" style="pointer-events: none;" class="inline"/></a></p>
<p ><a href="https://nodei.co/npm/z-schema/"><img src="https://nodei.co/npm/z-schema.png?downloads=true&amp;downloadRank=true" alt="NPM" class="inline"/></a></p>
<ul>
<li>version 3.0 runs also in the browsers now, run tests yourself <a href="https://rawgit.com/zaggino/z-schema/master/test/SpecRunner.html">here</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md3476"></a>
Topics</h1>
<ul>
<li>Usage</li>
<li>Features</li>
<li>Options</li>
<li>Benchmarks</li>
<li>Contributors</li>
</ul>
<h1><a class="anchor" id="autotoc_md3477"></a>
Usage</h1>
<p >Validator will try to perform sync validation when possible for speed, but supports async callbacks when they are necessary.</p>
<h2><a class="anchor" id="autotoc_md3478"></a>
Development:</h2>
<p >These repository has several submodules and should be cloned as follows: &gt;git clone <b>&ndash;recursive</b> <a href="https://github.com/zaggino/z-schema.git">https://github.com/zaggino/z-schema.git</a></p>
<h2><a class="anchor" id="autotoc_md3479"></a>
CLI:</h2>
<div class="fragment"><div class="line">npm install --global z-schema</div>
<div class="line">z-schema --help</div>
<div class="line">z-schema mySchema.json</div>
<div class="line">z-schema mySchema.json myJson.json</div>
<div class="line">z-schema --strictMode mySchema.json myJson.json</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3480"></a>
NodeJS:</h2>
<div class="fragment"><div class="line">var ZSchema = require(&quot;z-schema&quot;);</div>
<div class="line">var options = ... // see below for possible option values</div>
<div class="line">var validator = new ZSchema(options);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3481"></a>
Sync mode:</h2>
<div class="fragment"><div class="line">var valid = validator.validate(json, schema);</div>
<div class="line">// this will return a native error object with name and message</div>
<div class="line">var error = validator.getLastError();</div>
<div class="line">// this will return an array of validation errors encountered</div>
<div class="line">var errors = validator.getLastErrors();</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3482"></a>
Async mode:</h2>
<div class="fragment"><div class="line">validator.validate(json, schema, function (err, valid) {</div>
<div class="line">    ...</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3483"></a>
Browser:</h2>
<div class="fragment"><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../dist/ZSchema-browser-min.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div>
<div class="line">    var validator = new ZSchema();</div>
<div class="line">    var valid = validator.validate(&quot;string&quot;, { &quot;type&quot;: &quot;string&quot; });</div>
<div class="line">    console.log(valid);</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3484"></a>
Remote references and schemas:</h2>
<p >In case you have some remote references in your schemas, you have to download those schemas before using validator. Otherwise you'll get <code>UNRESOLVABLE_REFERENCE</code> error when trying to compile a schema.</p>
<div class="fragment"><div class="line">var validator = new ZSchema();</div>
<div class="line">var json = {};</div>
<div class="line">var schema = { &quot;$ref&quot;: &quot;http://json-schema.org/draft-04/schema#&quot; };</div>
<div class="line"> </div>
<div class="line">var valid = validator.validate(json, schema);</div>
<div class="line">var errors = validator.getLastErrors();</div>
<div class="line">// valid === false</div>
<div class="line">// errors.length === 1</div>
<div class="line">// errors[0].code === &quot;UNRESOLVABLE_REFERENCE&quot;</div>
<div class="line"> </div>
<div class="line">var requiredUrl = &quot;http://json-schema.org/draft-04/schema&quot;;</div>
<div class="line">request(requiredUrl, function (error, response, body) {</div>
<div class="line"> </div>
<div class="line">    validator.setRemoteReference(requiredUrl, JSON.parse(body));</div>
<div class="line"> </div>
<div class="line">    var valid = validator.validate(json, schema);</div>
<div class="line">    var errors = validator.getLastErrors();</div>
<div class="line">    // valid === true</div>
<div class="line">    // errors === undefined</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >If you're able to load schemas synchronously, you can use <code>ZSchema.setSchemaReader</code> feature:</p>
<div class="fragment"><div class="line">ZSchema.setSchemaReader(function (uri) {</div>
<div class="line">    var someFilename = path.resolve(__dirname, &quot;..&quot;, &quot;schemas&quot;, uri + &quot;.json&quot;);</div>
<div class="line">    return JSON.parse(fs.readFileSync(someFilename, &quot;utf8&quot;));</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3485"></a>
Features</h1>
<ul>
<li>Validate against subschema</li>
<li>Compile arrays of schemas and use references between them</li>
<li>Register a custom format</li>
<li>Automatic downloading of remote schemas</li>
<li>Prefill default values to object using format</li>
<li>Define a custom timeout for all async operations</li>
<li>Disallow validation of empty arrays as arrays</li>
<li>Disallow validation of empty strings as strings</li>
<li>Disallow schemas that don't have a type specified</li>
<li>Disallow schemas that contain unrecognized keywords and are not validated by parent schemas</li>
<li>Assume additionalItems/additionalProperties are defined in schemas as false</li>
<li>Force additionalItems/additionalProperties to be defined in schemas</li>
<li>Force items to be defined in array type schemas</li>
<li>Force minItems to be defined in array type schemas</li>
<li>Force maxItems to be defined in array type schemas</li>
<li>Force minLength to be defined in string type schemas</li>
<li>Force maxLength to be defined in string type schemas</li>
<li>Force properties or patternProperties to be defined in object type schemas</li>
<li>Ignore remote references to schemas that are not cached or resolvable</li>
<li>Ignore case mismatch when validating enum values</li>
<li>Only allow strictly absolute URIs to be used in schemas</li>
<li>Turn on z-schema strict mode</li>
<li>Set validator to collect as many errors as possible</li>
<li>Report paths in errors as arrays so they can be processed easier</li>
</ul>
<h2><a class="anchor" id="autotoc_md3486"></a>
Validate against subschema</h2>
<p >In case you don't want to split your schema into multiple schemas using reference for any reason, you can use option schemaPath when validating:</p>
<div class="fragment"><div class="line">var valid = validator.validate(cars, schema, { schemaPath: &quot;definitions.car.definitions.cars&quot; });</div>
</div><!-- fragment --><p >See more details in the <a href="/test/spec/schemaPathSpec.js">test</a>.</p>
<h2><a class="anchor" id="autotoc_md3487"></a>
Compile arrays of schemas and use references between them</h2>
<p >You can use validator to compile an array of schemas that have references between them and then validate against one of those schemas:</p>
<div class="fragment"><div class="line">var schemas = [</div>
<div class="line">    {</div>
<div class="line">        id: &quot;personDetails&quot;,</div>
<div class="line">        type: &quot;object&quot;,</div>
<div class="line">        properties: {</div>
<div class="line">            firstName: { type: &quot;string&quot; },</div>
<div class="line">            lastName: { type: &quot;string&quot; }</div>
<div class="line">        },</div>
<div class="line">        required: [&quot;firstName&quot;, &quot;lastName&quot;]</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">        id: &quot;addressDetails&quot;,</div>
<div class="line">        type: &quot;object&quot;,</div>
<div class="line">        properties: {</div>
<div class="line">            street: { type: &quot;string&quot; },</div>
<div class="line">            city: { type: &quot;string&quot; }</div>
<div class="line">        },</div>
<div class="line">        required: [&quot;street&quot;, &quot;city&quot;]</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">        id: &quot;personWithAddress&quot;,</div>
<div class="line">        allOf: [</div>
<div class="line">            { $ref: &quot;personDetails&quot; },</div>
<div class="line">            { $ref: &quot;addressDetails&quot; }</div>
<div class="line">        ]</div>
<div class="line">    }</div>
<div class="line">];</div>
<div class="line"> </div>
<div class="line">var data = {</div>
<div class="line">    firstName: &quot;Martin&quot;,</div>
<div class="line">    lastName: &quot;Zagora&quot;,</div>
<div class="line">    street: &quot;George St&quot;,</div>
<div class="line">    city: &quot;Sydney&quot;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">var validator = new ZSchema();</div>
<div class="line"> </div>
<div class="line">// compile &amp; validate schemas first, z-schema will automatically handle array</div>
<div class="line">var allSchemasValid = validator.validateSchema(schemas);</div>
<div class="line">// allSchemasValid === true</div>
<div class="line"> </div>
<div class="line">// now validate our data against the last schema</div>
<div class="line">var valid = validator.validate(data, schemas[2]);</div>
<div class="line">// valid === true</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3488"></a>
Register a custom format</h2>
<p >You can register any format of your own. Your sync validator function should always respond with a boolean:</p>
<div class="fragment"><div class="line">ZSchema.registerFormat(&quot;xstring&quot;, function (str) {</div>
<div class="line">    return str === &quot;xxx&quot;;</div>
<div class="line">});</div>
</div><!-- fragment --><p >Async format validators are also supported, they should accept two arguments, value and a callback to which they need to respond:</p>
<div class="fragment"><div class="line">ZSchema.registerFormat(&quot;xstring&quot;, function (str, callback) {</div>
<div class="line">    setTimeout(function () {</div>
<div class="line">        callback(str === &quot;xxx&quot;);</div>
<div class="line">    }, 1);</div>
<div class="line">});</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md3489"></a>
Helper method to check the formats that have been registered</h2>
<div class="fragment"><div class="line">var registeredFormats = ZSchema.getRegisteredFormats();</div>
<div class="line">//registeredFormats will now contain an array of all formats that have been registered with z-schema</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md3490"></a>
Automatic downloading of remote schemas</h2>
<p >Automatic downloading of remote schemas was removed from version <code>3.x</code> but is still possible with a bit of extra code, see <a href="test/spec/AutomaticSchemaLoadingSpec.js">this test</a> for more information on this.</p>
<h2><a class="anchor" id="autotoc_md3491"></a>
Prefill default values to object using format</h2>
<p >Using format, you can pre-fill values of your choosing into the objects like this:</p>
<div class="fragment"><div class="line">ZSchema.registerFormat(&quot;fillHello&quot;, function (obj) {</div>
<div class="line">    obj.hello = &quot;world&quot;;</div>
<div class="line">    return true;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">var data = {};</div>
<div class="line"> </div>
<div class="line">var schema = {</div>
<div class="line">    &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">    &quot;format&quot;: &quot;fillHello&quot;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">validator.validate(data, schema);</div>
<div class="line">// data.hello === &quot;world&quot;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3492"></a>
Options</h1>
<h2><a class="anchor" id="autotoc_md3493"></a>
asyncTimeout</h2>
<p >Defines a time limit, which should be used when waiting for async tasks like async format validators to perform their validation, before the validation fails with an <code>ASYNC_TIMEOUT</code> error.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    asyncTimeout: 2000</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3494"></a>
noEmptyArrays</h2>
<p >When true, validator will assume that minimum count of items in any <code>array</code> is 1, except when <code>minItems: 0</code> is explicitly defined.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    noEmptyArrays: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3495"></a>
noEmptyStrings</h2>
<p >When true, validator will assume that minimum length of any string to pass type <code>string</code> validation is 1, except when <code>minLength: 0</code> is explicitly defined.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    noEmptyStrings: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3496"></a>
noTypeless</h2>
<p >When true, validator will fail validation for schemas that don't specify a <code>type</code> of object that they expect.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    noTypeless: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3497"></a>
noExtraKeywords</h2>
<p >When true, validator will fail for schemas that use keywords not defined in JSON Schema specification and doesn't provide a parent schema in <code>$schema</code> property to validate the schema.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    noExtraKeywords: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3498"></a>
assumeAdditional</h2>
<p >When true, validator assumes that additionalItems/additionalProperties are defined as false so you don't have to manually fix all your schemas.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    assumeAdditional: true</div>
<div class="line">});</div>
</div><!-- fragment --><p >When an array, validator assumes that additionalItems/additionalProperties are defined as false, but allows some properties to pass.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    assumeAdditional: [&quot;$ref&quot;]</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3499"></a>
forceAdditional</h2>
<p >When true, validator doesn't validate schemas where additionalItems/additionalProperties should be defined to either true or false.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceAdditional: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3500"></a>
forceItems</h2>
<p >When true, validator doesn't validate schemas where <code>items</code> are not defined for <code>array</code> type schemas. This is to avoid passing anything through an array definition.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceItems: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3501"></a>
forceMinItems</h2>
<p >When true, validator doesn't validate schemas where <code>minItems</code> is not defined for <code>array</code> type schemas. This is to avoid passing zero-length arrays which application doesn't expect to handle.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceMinItems: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3502"></a>
forceMaxItems</h2>
<p >When true, validator doesn't validate schemas where <code>maxItems</code> is not defined for <code>array</code> type schemas. This is to avoid passing arrays with unlimited count of elements which application doesn't expect to handle.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceMaxItems: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3503"></a>
forceMinLength</h2>
<p >When true, validator doesn't validate schemas where <code>minLength</code> is not defined for <code>string</code> type schemas. This is to avoid passing zero-length strings which application doesn't expect to handle.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceMinLength: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3504"></a>
forceMaxLength</h2>
<p >When true, validator doesn't validate schemas where <code>maxLength</code> is not defined for <code>string</code> type schemas. This is to avoid passing extremly large strings which application doesn't expect to handle.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceMaxLength: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3505"></a>
forceProperties</h2>
<p >When true, validator doesn't validate schemas where <code>properties</code> or <code>patternProperties</code> is not defined for <code>object</code> type schemas. This is to avoid having objects with unexpected properties in application.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    forceProperties: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3506"></a>
ignoreUnresolvableReferences</h2>
<p >When true, validator doesn't end with error when a remote reference is unreachable. <b>This setting is not recommended in production outside of testing.</b></p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    ignoreUnresolvableReferences: true</div>
<div class="line">});</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md3507"></a>
enumCaseInsensitiveComparison</h2>
<p >When true, validator will return a <code>ENUM_CASE_MISMATCH</code> when the enum values mismatch only in case.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    enumCaseInsensitiveComparison: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3508"></a>
strictUris</h2>
<p >When true, all strings of format <code>uri</code> must be an absolute URIs and not only URI references. See more details in <a href="https://github.com/zaggino/z-schema/issues/18">this issue</a>.</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    strictUris: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3509"></a>
strictMode</h2>
<p >Strict mode of z-schema is currently equal to the following:</p>
<div class="fragment"><div class="line">if (this.options.strictMode === true) {</div>
<div class="line">    this.options.forceAdditional  = true;</div>
<div class="line">    this.options.forceItems       = true;</div>
<div class="line">    this.options.forceMaxLength   = true;</div>
<div class="line">    this.options.forceProperties  = true;</div>
<div class="line">    this.options.noExtraKeywords  = true;</div>
<div class="line">    this.options.noTypeless       = true;</div>
<div class="line">    this.options.noEmptyStrings   = true;</div>
<div class="line">    this.options.noEmptyArrays    = true;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    strictMode: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3510"></a>
breakOnFirstError</h2>
<p >default: <code>false</code><br  />
 When true, will stop validation after the first error is found:</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    breakOnFirstError: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3511"></a>
reportPathAsArray</h2>
<p >Report error paths as an array of path segments instead of a string:</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    reportPathAsArray: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3512"></a>
ignoreUnknownFormats</h2>
<p >By default, z-schema reports all unknown formats, formats not defined by JSON Schema and not registered using <code>ZSchema.registerFormat</code>, as an error. But the <a href="http://json-schema.org/latest/json-schema-validation.html#anchor106">JSON Schema specification</a> says that validator implementations *"they SHOULD offer an option to disable validation"* for <code>format</code>. That being said, setting this option to <code>true</code> will disable treating unknown formats as errlrs</p>
<div class="fragment"><div class="line">var validator = new ZSchema({</div>
<div class="line">    ignoreUnknownFormats: true</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3513"></a>
includeErrors</h2>
<p >By default, z-schema reports all errors. If interested only in a subset of the errors, passing the option <code>includeErrors</code> to <code>validate</code> will perform validations only for those errors.</p>
<div class="fragment"><div class="line">var validator = new ZSchema();</div>
<div class="line">// will only execute validation for &quot;INVALID_TYPE&quot; error.</div>
<div class="line">validator.validate(json, schema, {includeErrors: [&quot;INVALID_TYPE&quot;]});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3514"></a>
customValidator</h2>
<p ><b>Warning</b>: Use only if know what you are doing. Always consider using custom format before using this option.</p>
<p >Register function to be called as part of validation process on every subshema encounter during validation.</p>
<p >Let's make a real-life example with this feature. Imagine you have number of transactions: </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;fromId&quot;: 1034834329,</div>
<div class="line">    &quot;toId&quot;: 1034834543,</div>
<div class="line">    &quot;amount&quot;: 200</div>
<div class="line">}</div>
</div><!-- fragment --><p> So you write the schema: </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">    &quot;properties&quot;: {</div>
<div class="line">        &quot;fromId&quot;: {</div>
<div class="line">            &quot;type&quot;: &quot;integer&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;toId&quot;: {</div>
<div class="line">            &quot;type&quot;: &quot;integer&quot;</div>
<div class="line">        },</div>
<div class="line">        &quot;amount&quot;: {</div>
<div class="line">            &quot;type&quot;: &quot;number&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> But how to check that <code>fromId</code> and <code>toId</code> are never equal. In JSON Schema Draft4 there is no possibility to do this. Actually, it's easy to just write validation code for such simple payloads. But what if you have to do the same check for many objects in different places of JSON payload. One solution is to add custom keyword <code>uniqueProperties</code> with array of property names as a value. So in our schema we would need to add: </p><div class="fragment"><div class="line">&quot;uniqueProperties&quot;: [</div>
<div class="line">    &quot;fromId&quot;,</div>
<div class="line">    &quot;toId&quot;</div>
<div class="line">]</div>
</div><!-- fragment --><p> To teach <code>z-schema</code> about this new keyword we need to write handler for it: </p><div class="fragment"><div class="line">function customValidatorFn(report, schema, json) {</div>
<div class="line">    // check if our custom property is present</div>
<div class="line">    if (Array.isArray(schema.uniqueProperties)) {</div>
<div class="line">        var seenValues = [];</div>
<div class="line">        schema.uniqueProperties.forEach(function (prop) {</div>
<div class="line">            var value = json[prop];</div>
<div class="line">            if (typeof value !== &#39;undefined&#39;) {</div>
<div class="line">                if (seenValues.indexOf(value) !== -1) {</div>
<div class="line">                    // report error back to z-schema core</div>
<div class="line">                    report.addCustomError(&quot;NON_UNIQUE_PROPERTY_VALUE&quot;,</div>
<div class="line">                        &quot;Property \&quot;{0}\&quot; has non-unique value: {1}&quot;,</div>
<div class="line">                        [prop, value], null, schema.description);</div>
<div class="line">                }</div>
<div class="line">                seenValues.push(value)</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">var validator = new ZSchema({</div>
<div class="line">    // register our custom validator inside z-schema</div>
<div class="line">    customValidator: customValidatorFn</div>
<div class="line">});</div>
</div><!-- fragment --><p> Let's test it: </p><div class="fragment"><div class="line">var data = {</div>
<div class="line">    fromId: 1034834346,</div>
<div class="line">    toId: 1034834346,</div>
<div class="line">    amount: 50</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">validator.validate(data, schema);</div>
<div class="line">console.log(validator.getLastErrors())</div>
<div class="line">//[ { code: &#39;NON_UNIQUE_PROPERTY_VALUE&#39;,</div>
<div class="line">//    params: [ &#39;toId&#39;, 1034834346 ],</div>
<div class="line">//    message: &#39;Property &quot;toId&quot; has non-unique value: 1034834346&#39;,</div>
<div class="line">//    path: &#39;#/&#39;,</div>
<div class="line">//    schemaId: undefined } ]</div>
</div><!-- fragment --><p> <b>Note:</b> before creating your own keywords you should consider all compatibility issues.</p>
<h1><a class="anchor" id="autotoc_md3515"></a>
Benchmarks</h1>
<p >So how does it compare to version 2.x and others?</p>
<p ><b>NOTE: these tests are purely orientational, they don't consider extra features any of the validator may support and implement</b></p>
<p ><a href="https://rawgithub.com/zaggino/z-schema/master/benchmark/results.html">rawgithub.com/zaggino/z-schema/master/benchmark/results.html</a></p>
<h1><a class="anchor" id="autotoc_md3516"></a>
Contributors</h1>
<p >Thanks for contributing to:</p>
<ul>
<li><a href="https://github.com/whitlockjc">Jeremy Whitlock</a></li>
<li><a href="https://github.com/oleksiyk">Oleksiy Krivoshey</a></li>
</ul>
<p >and to everyone submitting <a href="https://github.com/zaggino/z-schema/issues">issues</a> on GitHub </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
