<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Códigos Generales Sprint 0 PBIO: lru-cache</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Códigos Generales Sprint 0 PBIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Buscar','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">lru-cache </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >A cache object that deletes the least-recently-used items.</p>
<p >Specify a max number of the most recently used items that you want to keep, and this cache will keep that many of the most recently accessed items.</p>
<p >This is not primarily a TTL cache, and does not make strong TTL guarantees. There is no preemptive pruning of expired items by default, but you <em>may</em> set a TTL on the cache or on a single <code>set</code>. If you do so, it will treat expired items as missing, and delete them when fetched. If you are more interested in TTL caching than LRU caching, check out <a href="http://npm.im/@isaacs/ttlcache">@isaacs/ttlcache</a>.</p>
<p >As of version 7, this is one of the most performant LRU implementations available in JavaScript, and supports a wide diversity of use cases. However, note that using some of the features will necessarily impact performance, by causing the cache to have to do more work. See the "Performance" section below.</p>
<h1><a class="anchor" id="autotoc_md1671"></a>
Installation</h1>
<div class="fragment"><div class="line">npm install lru-cache --save</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1672"></a>
Usage</h1>
<div class="fragment"><div class="line">// hybrid module, either works</div>
<div class="line">import LRUCache from &#39;lru-cache&#39;</div>
<div class="line">// or:</div>
<div class="line">const LRUCache = require(&#39;lru-cache&#39;)</div>
<div class="line"> </div>
<div class="line">// At least one of &#39;max&#39;, &#39;ttl&#39;, or &#39;maxSize&#39; is required, to prevent</div>
<div class="line">// unsafe unbounded storage.</div>
<div class="line">//</div>
<div class="line">// In most cases, it&#39;s best to specify a max for performance, so all</div>
<div class="line">// the required memory allocation is done up-front.</div>
<div class="line">//</div>
<div class="line">// All the other options are optional, see the sections below for</div>
<div class="line">// documentation on what each one does.  Most of them can be</div>
<div class="line">// overridden for specific items in get()/set()</div>
<div class="line">const options = {</div>
<div class="line">  max: 500,</div>
<div class="line"> </div>
<div class="line">  // for use with tracking overall storage size</div>
<div class="line">  maxSize: 5000,</div>
<div class="line">  sizeCalculation: (value, key) =&gt; {</div>
<div class="line">    return 1</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  // for use when you need to clean up something when objects</div>
<div class="line">  // are evicted from the cache</div>
<div class="line">  dispose: (value, key) =&gt; {</div>
<div class="line">    freeFromMemoryOrWhatever(value)</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  // how long to live in ms</div>
<div class="line">  ttl: 1000 * 60 * 5,</div>
<div class="line"> </div>
<div class="line">  // return stale items before removing from cache?</div>
<div class="line">  allowStale: false,</div>
<div class="line"> </div>
<div class="line">  updateAgeOnGet: false,</div>
<div class="line">  updateAgeOnHas: false,</div>
<div class="line"> </div>
<div class="line">  // async method to use for cache.fetch(), for</div>
<div class="line">  // stale-while-revalidate type of behavior</div>
<div class="line">  fetchMethod: async (key, staleValue, { options, signal }) =&gt; {},</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const cache = new LRUCache(options)</div>
<div class="line"> </div>
<div class="line">cache.set(&#39;key&#39;, &#39;value&#39;)</div>
<div class="line">cache.get(&#39;key&#39;) // &quot;value&quot;</div>
<div class="line"> </div>
<div class="line">// non-string keys ARE fully supported</div>
<div class="line">// but note that it must be THE SAME object, not</div>
<div class="line">// just a JSON-equivalent object.</div>
<div class="line">var someObject = { a: 1 }</div>
<div class="line">cache.set(someObject, &#39;a value&#39;)</div>
<div class="line">// Object keys are not toString()-ed</div>
<div class="line">cache.set(&#39;[object Object]&#39;, &#39;a different value&#39;)</div>
<div class="line">assert.equal(cache.get(someObject), &#39;a value&#39;)</div>
<div class="line">// A similar object with same keys/values won&#39;t work,</div>
<div class="line">// because it&#39;s a different object identity</div>
<div class="line">assert.equal(cache.get({ a: 1 }), undefined)</div>
<div class="line"> </div>
<div class="line">cache.clear() // empty the cache</div>
</div><!-- fragment --><p >If you put more stuff in it, then items will fall out.</p>
<h1><a class="anchor" id="autotoc_md1673"></a>
Options</h1>
<h2><a class="anchor" id="autotoc_md1674"></a>
&lt;tt&gt;max&lt;/tt&gt;</h2>
<p >The maximum number of items that remain in the cache (assuming no TTL pruning or explicit deletions). Note that fewer items may be stored if size calculation is used, and <code>maxSize</code> is exceeded. This must be a positive finite intger.</p>
<p >At least one of <code>max</code>, <code>maxSize</code>, or <code>TTL</code> is required. This must be a positive integer if set.</p>
<p ><b>It is strongly recommended to set a <code>max</code> to prevent unbounded growth of the cache.</b> See "Storage Bounds Safety" below.</p>
<h2><a class="anchor" id="autotoc_md1675"></a>
&lt;tt&gt;maxSize&lt;/tt&gt;</h2>
<p >Set to a positive integer to track the sizes of items added to the cache, and automatically evict items in order to stay below this size. Note that this may result in fewer than <code>max</code> items being stored.</p>
<p >Attempting to add an item to the cache whose calculated size is greater that this amount will be a no-op. The item will not be cached, and no other items will be evicted.</p>
<p >Optional, must be a positive integer if provided.</p>
<p >Sets <code>maxEntrySize</code> to the same value, unless a different value is provided for <code>maxEntrySize</code>.</p>
<p >At least one of <code>max</code>, <code>maxSize</code>, or <code>TTL</code> is required. This must be a positive integer if set.</p>
<p >Even if size tracking is enabled, <b>it is strongly recommended to set a <code>max</code> to prevent unbounded growth of the cache.</b> See "Storage Bounds Safety" below.</p>
<h2><a class="anchor" id="autotoc_md1676"></a>
&lt;tt&gt;maxEntrySize&lt;/tt&gt;</h2>
<p >Set to a positive integer to track the sizes of items added to the cache, and prevent caching any item over a given size. Attempting to add an item whose calculated size is greater than this amount will be a no-op. The item will not be cached, and no other items will be evicted.</p>
<p >Optional, must be a positive integer if provided. Defaults to the value of <code>maxSize</code> if provided.</p>
<h2><a class="anchor" id="autotoc_md1677"></a>
&lt;tt&gt;sizeCalculation&lt;/tt&gt;</h2>
<p >Function used to calculate the size of stored items. If you're storing strings or buffers, then you probably want to do something like <code>n =&gt; n.length</code>. The item is passed as the first argument, and the key is passed as the second argument.</p>
<p >This may be overridden by passing an options object to <code>cache.set()</code>.</p>
<p >Requires <code>maxSize</code> to be set.</p>
<p >If the <code>size</code> (or return value of <code>sizeCalculation</code>) for a given entry is greater than <code>maxEntrySize</code>, then the item will not be added to the cache.</p>
<p >Deprecated alias: <code>length</code></p>
<h2><a class="anchor" id="autotoc_md1678"></a>
&lt;tt&gt;fetchMethod&lt;/tt&gt;</h2>
<p >Function that is used to make background asynchronous fetches. Called with <code>fetchMethod(key, staleValue, { signal, options, context })</code>. May return a Promise.</p>
<p >If <code>fetchMethod</code> is not provided, then <code>cache.fetch(key)</code> is equivalent to <code>Promise.resolve(cache.get(key))</code>.</p>
<p >The <code>signal</code> object is an <code>AbortSignal</code> if that's available in the global object, otherwise it's a pretty close polyfill.</p>
<p >If at any time, <code>signal.aborted</code> is set to <code>true</code>, or if the <code>signal.onabort</code> method is called, or if it emits an &lsquo;'abort&rsquo;<code> event which you can listen to with</code>addEventListener`, then that means that the fetch should be abandoned. This may be passed along to async functions aware of AbortController/AbortSignal behavior.</p>
<p >The <code>fetchMethod</code> should <b>only</b> return <code>undefined</code> or a Promise resolving to <code>undefined</code> if the AbortController signaled an <code>abort</code> event. In all other cases, it should return or resolve to a value suitable for adding to the cache.</p>
<p >The <code>options</code> object is a union of the options that may be provided to <code>set()</code> and <code>get()</code>. If they are modified, then that will result in modifying the settings to <code>cache.set()</code> when the value is resolved, and in the case of <code>noDeleteOnFetchRejection</code> and <code>allowStaleOnFetchRejection</code>, the handling of <code>fetchMethod</code> failures.</p>
<p >For example, a DNS cache may update the TTL based on the value returned from a remote DNS server by changing <code>options.ttl</code> in the <code>fetchMethod</code>.</p>
<h2><a class="anchor" id="autotoc_md1679"></a>
&lt;tt&gt;fetchContext&lt;/tt&gt;</h2>
<p >Arbitrary data that can be passed to the <code>fetchMethod</code> as the <code>context</code> option.</p>
<p >Note that this will only be relevant when the <code>cache.fetch()</code> call needs to call <code>fetchMethod()</code>. Thus, any data which will meaningfully vary the fetch response needs to be present in the key. This is primarily intended for including <code>x-request-id</code> headers and the like for debugging purposes, which do not affect the <code>fetchMethod()</code> response.</p>
<h2><a class="anchor" id="autotoc_md1680"></a>
&lt;tt&gt;noDeleteOnFetchRejection&lt;/tt&gt;</h2>
<p >If a <code>fetchMethod</code> throws an error or returns a rejected promise, then by default, any existing stale value will be removed from the cache.</p>
<p >If <code>noDeleteOnFetchRejection</code> is set to <code>true</code>, then this behavior is suppressed, and the stale value remains in the cache in the case of a rejected <code>fetchMethod</code>.</p>
<p >This is important in cases where a <code>fetchMethod</code> is <em>only</em> called as a background update while the stale value is returned, when <code>allowStale</code> is used.</p>
<p >This is implicitly in effect when <code>allowStaleOnFetchRejection</code> is set.</p>
<p >This may be set in calls to <code>fetch()</code>, or defaulted on the constructor, or overridden by modifying the options object in the <code>fetchMethod</code>.</p>
<h2><a class="anchor" id="autotoc_md1681"></a>
&lt;tt&gt;allowStaleOnFetchRejection&lt;/tt&gt;</h2>
<p >Set to true to return a stale value from the cache when a <code>fetchMethod</code> throws an error or returns a rejected Promise.</p>
<p >If a <code>fetchMethod</code> fails, and there is no stale value available, the <code>fetch()</code> will resolve to <code>undefined</code>. Ie, all <code>fetchMethod</code> errors are suppressed.</p>
<p >Implies <code>noDeleteOnFetchRejection</code>.</p>
<p >This may be set in calls to <code>fetch()</code>, or defaulted on the constructor, or overridden by modifying the options object in the <code>fetchMethod</code>.</p>
<h2><a class="anchor" id="autotoc_md1682"></a>
&lt;tt&gt;allowStaleOnFetchAbort&lt;/tt&gt;</h2>
<p >Set to true to return a stale value from the cache when the <code>AbortSignal</code> passed to the <code>fetchMethod</code> dispatches an &lsquo;'abort&rsquo;` event, whether user-triggered, or due to internal cache behavior.</p>
<p >Unless <code>ignoreFetchAbort</code> is also set, the underlying <code>fetchMethod</code> will still be considered canceled, and its return value will be ignored and not cached.</p>
<h2><a class="anchor" id="autotoc_md1683"></a>
&lt;tt&gt;ignoreFetchAbort&lt;/tt&gt;</h2>
<p >Set to true to ignore the <code>abort</code> event emitted by the <code>AbortSignal</code> object passed to <code>fetchMethod</code>, and still cache the resulting resolution value, as long as it is not <code>undefined</code>.</p>
<p >When used on its own, this means aborted <code>fetch()</code> calls are not immediately resolved or rejected when they are aborted, and instead take the full time to await.</p>
<p >When used with <code>allowStaleOnFetchAbort</code>, aborted <code>fetch()</code> calls will resolve immediately to their stale cached value or <code>undefined</code>, and will continue to process and eventually update the cache when they resolve, as long as the resulting value is not <code>undefined</code>, thus supporting a "return stale on timeout while
refreshing" mechanism by passing <code>AbortSignal.timeout(n)</code> as the signal.</p>
<p >For example:</p>
<div class="fragment"><div class="line">const c = new LRUCache({</div>
<div class="line">  ttl: 100,</div>
<div class="line">  ignoreFetchAbort: true,</div>
<div class="line">  allowStaleOnFetchAbort: true,</div>
<div class="line">  fetchMethod: async (key, oldValue, { signal }) =&gt; {</div>
<div class="line">    // note: do NOT pass the signal to fetch()!</div>
<div class="line">    // let&#39;s say this fetch can take a long time.</div>
<div class="line">    const res = await fetch(`https://slow-backend-server/${key}`)</div>
<div class="line">    return await res.json()</div>
<div class="line">  },</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// this will return the stale value after 100ms, while still</div>
<div class="line">// updating in the background for next time.</div>
<div class="line">const val = await c.fetch(&#39;key&#39;, { signal: AbortSignal.timeout(100) })</div>
</div><!-- fragment --><p ><b>Note</b>: regardless of this setting, an <code>abort</code> event <em>is still emitted on the <code>AbortSignal</code> object</em>, so may result in invalid results when passed to other underlying APIs that use AbortSignals.</p>
<p >This may be overridden on the <code>fetch()</code> call or in the <code>fetchMethod</code> itself.</p>
<h2><a class="anchor" id="autotoc_md1684"></a>
&lt;tt&gt;dispose&lt;/tt&gt;</h2>
<p >Function that is called on items when they are dropped from the cache, as <code>this.dispose(value, key, reason)</code>.</p>
<p >This can be handy if you want to close file descriptors or do other cleanup tasks when items are no longer stored in the cache.</p>
<p ><b>NOTE</b>: It is called <em>before</em> the item has been fully removed from the cache, so if you want to put it right back in, you need to wait until the next tick. If you try to add it back in during the <code>dispose()</code> function call, it will break things in subtle and weird ways.</p>
<p >Unlike several other options, this may <em>not</em> be overridden by passing an option to <code>set()</code>, for performance reasons. If disposal functions may vary between cache entries, then the entire list must be scanned on every cache swap, even if no disposal function is in use.</p>
<p >The <code>reason</code> will be one of the following strings, corresponding to the reason for the item's deletion:</p>
<ul>
<li><code>evict</code> Item was evicted to make space for a new addition</li>
<li><code>set</code> Item was overwritten by a new value</li>
<li><code>delete</code> Item was removed by explicit <code>cache.delete(key)</code> or by calling <code>cache.clear()</code>, which deletes everything.</li>
</ul>
<p >The <code>dispose()</code> method is <em>not</em> called for canceled calls to <code>fetchMethod()</code>. If you wish to handle evictions, overwrites, and deletes of in-flight asynchronous fetches, you must use the <code>AbortSignal</code> provided.</p>
<p >Optional, must be a function.</p>
<h2><a class="anchor" id="autotoc_md1685"></a>
&lt;tt&gt;disposeAfter&lt;/tt&gt;</h2>
<p >The same as <code>dispose</code>, but called <em>after</em> the entry is completely removed and the cache is once again in a clean state.</p>
<p >It is safe to add an item right back into the cache at this point. However, note that it is <em>very</em> easy to inadvertently create infinite recursion in this way.</p>
<p >The <code>disposeAfter()</code> method is <em>not</em> called for canceled calls to <code>fetchMethod()</code>. If you wish to handle evictions, overwrites, and deletes of in-flight asynchronous fetches, you must use the <code>AbortSignal</code> provided.</p>
<h2><a class="anchor" id="autotoc_md1686"></a>
&lt;tt&gt;noDisposeOnSet&lt;/tt&gt;</h2>
<p >Set to <code>true</code> to suppress calling the <code>dispose()</code> function if the entry key is still accessible within the cache.</p>
<p >This may be overridden by passing an options object to <code>cache.set()</code>.</p>
<p >Boolean, default <code>false</code>. Only relevant if <code>dispose</code> or <code>disposeAfter</code> options are set.</p>
<h2><a class="anchor" id="autotoc_md1687"></a>
&lt;tt&gt;ttl&lt;/tt&gt;</h2>
<p >Max time to live for items before they are considered stale. Note that stale items are NOT preemptively removed by default, and MAY live in the cache, contributing to its LRU max, long after they have expired.</p>
<p >Also, as this cache is optimized for LRU/MRU operations, some of the staleness/TTL checks will reduce performance.</p>
<p >This is not primarily a TTL cache, and does not make strong TTL guarantees. There is no pre-emptive pruning of expired items, but you <em>may</em> set a TTL on the cache, and it will treat expired items as missing when they are fetched, and delete them.</p>
<p >Optional, but must be a positive integer in ms if specified.</p>
<p >This may be overridden by passing an options object to <code>cache.set()</code>.</p>
<p >At least one of <code>max</code>, <code>maxSize</code>, or <code>TTL</code> is required. This must be a positive integer if set.</p>
<p >Even if ttl tracking is enabled, <b>it is strongly recommended to set a <code>max</code> to prevent unbounded growth of the cache.</b> See "Storage Bounds Safety" below.</p>
<p >If ttl tracking is enabled, and <code>max</code> and <code>maxSize</code> are not set, and <code>ttlAutopurge</code> is not set, then a warning will be emitted cautioning about the potential for unbounded memory consumption.</p>
<p >Deprecated alias: <code>maxAge</code></p>
<h2><a class="anchor" id="autotoc_md1688"></a>
&lt;tt&gt;noUpdateTTL&lt;/tt&gt;</h2>
<p >Boolean flag to tell the cache to not update the TTL when setting a new value for an existing key (ie, when updating a value rather than inserting a new value). Note that the TTL value is <em>always</em> set (if provided) when adding a new entry into the cache.</p>
<p >This may be passed as an option to <code>cache.set()</code>.</p>
<p >Boolean, default false.</p>
<h2><a class="anchor" id="autotoc_md1689"></a>
&lt;tt&gt;ttlResolution&lt;/tt&gt;</h2>
<p >Minimum amount of time in ms in which to check for staleness. Defaults to <code>1</code>, which means that the current time is checked at most once per millisecond.</p>
<p >Set to <code>0</code> to check the current time every time staleness is tested.</p>
<p >Note that setting this to a higher value <em>will</em> improve performance somewhat while using ttl tracking, albeit at the expense of keeping stale items around a bit longer than intended.</p>
<h2><a class="anchor" id="autotoc_md1690"></a>
&lt;tt&gt;ttlAutopurge&lt;/tt&gt;</h2>
<p >Preemptively remove stale items from the cache.</p>
<p >Note that this may <em>significantly</em> degrade performance, especially if the cache is storing a large number of items. It is almost always best to just leave the stale items in the cache, and let them fall out as new items are added.</p>
<p >Note that this means that <code>allowStale</code> is a bit pointless, as stale items will be deleted almost as soon as they expire.</p>
<p >Use with caution!</p>
<p >Boolean, default <code>false</code></p>
<h2><a class="anchor" id="autotoc_md1691"></a>
&lt;tt&gt;allowStale&lt;/tt&gt;</h2>
<p >By default, if you set <code>ttl</code>, it'll only delete stale items from the cache when you <code>get(key)</code>. That is, it's not preemptively pruning items.</p>
<p >If you set <code>allowStale:true</code>, it'll return the stale value as well as deleting it. If you don't set this, then it'll return <code>undefined</code> when you try to get a stale entry.</p>
<p >Note that when a stale entry is fetched, <em>even if it is returned due to <code>allowStale</code> being set</em>, it is removed from the cache immediately. You can immediately put it back in the cache if you wish, thus resetting the TTL.</p>
<p >This may be overridden by passing an options object to <code>cache.get()</code>. The <code>cache.has()</code> method will always return <code>false</code> for stale items.</p>
<p >Boolean, default false, only relevant if <code>ttl</code> is set.</p>
<p >Deprecated alias: <code>stale</code></p>
<h2><a class="anchor" id="autotoc_md1692"></a>
&lt;tt&gt;noDeleteOnStaleGet&lt;/tt&gt;</h2>
<p >When using time-expiring entries with <code>ttl</code>, by default stale items will be removed from the cache when the key is accessed with <code>cache.get()</code>.</p>
<p >Setting <code>noDeleteOnStaleGet</code> to <code>true</code> will cause stale items to remain in the cache, until they are explicitly deleted with <code>cache.delete(key)</code>, or retrieved with <code>noDeleteOnStaleGet</code> set to <code>false</code>.</p>
<p >This may be overridden by passing an options object to <code>cache.get()</code>.</p>
<p >Boolean, default false, only relevant if <code>ttl</code> is set.</p>
<h2><a class="anchor" id="autotoc_md1693"></a>
&lt;tt&gt;updateAgeOnGet&lt;/tt&gt;</h2>
<p >When using time-expiring entries with <code>ttl</code>, setting this to <code>true</code> will make each item's age reset to 0 whenever it is retrieved from cache with <code>get()</code>, causing it to not expire. (It can still fall out of cache based on recency of use, of course.)</p>
<p >This may be overridden by passing an options object to <code>cache.get()</code>.</p>
<p >Boolean, default false, only relevant if <code>ttl</code> is set.</p>
<h2><a class="anchor" id="autotoc_md1694"></a>
&lt;tt&gt;updateAgeOnHas&lt;/tt&gt;</h2>
<p >When using time-expiring entries with <code>ttl</code>, setting this to <code>true</code> will make each item's age reset to 0 whenever its presence in the cache is checked with <code>has()</code>, causing it to not expire. (It can still fall out of cache based on recency of use, of course.)</p>
<p >This may be overridden by passing an options object to <code>cache.has()</code>.</p>
<p >Boolean, default false, only relevant if <code>ttl</code> is set.</p>
<h1><a class="anchor" id="autotoc_md1695"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md1696"></a>
&lt;tt&gt;new LRUCache(options)&lt;/tt&gt;</h2>
<p >Create a new LRUCache. All options are documented above, and are on the cache as public members.</p>
<h2><a class="anchor" id="autotoc_md1697"></a>
&lt;tt&gt;cache.max&lt;/tt&gt;, &lt;tt&gt;cache.maxSize&lt;/tt&gt;, &lt;tt&gt;cache.allowStale&lt;/tt&gt;,</h2>
<p ><code>cache.noDisposeOnSet</code>, <code>cache.sizeCalculation</code>, <code>cache.dispose</code>, <code>cache.maxSize</code>, <code>cache.ttl</code>, <code>cache.updateAgeOnGet</code>, <code>cache.updateAgeOnHas</code></p>
<p >All option names are exposed as public members on the cache object.</p>
<p >These are intended for read access only. Changing them during program operation can cause undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md1698"></a>
&lt;tt&gt;cache.size&lt;/tt&gt;</h2>
<p >The total number of items held in the cache at the current moment.</p>
<h2><a class="anchor" id="autotoc_md1699"></a>
&lt;tt&gt;cache.calculatedSize&lt;/tt&gt;</h2>
<p >The total size of items in cache when using size tracking.</p>
<h2><a class="anchor" id="autotoc_md1700"></a>
&lt;tt&gt;set(key, value, [{ size, sizeCalculation, ttl, noDisposeOnSet, start, status }])&lt;/tt&gt;</h2>
<p >Add a value to the cache.</p>
<p >Optional options object may contain <code>ttl</code> and <code>sizeCalculation</code> as described above, which default to the settings on the cache object.</p>
<p >If <code>start</code> is provided, then that will set the effective start time for the TTL calculation. Note that this must be a previous value of <code>performance.now()</code> if supported, or a previous value of <code>Date.now()</code> if not.</p>
<p >Options object may also include <code>size</code>, which will prevent calling the <code>sizeCalculation</code> function and just use the specified number if it is a positive integer, and <code>noDisposeOnSet</code> which will prevent calling a <code>dispose</code> function in the case of overwrites.</p>
<p >If the <code>size</code> (or return value of <code>sizeCalculation</code>) for a given entry is greater than <code>maxEntrySize</code>, then the item will not be added to the cache.</p>
<p >Will update the recency of the entry.</p>
<p >Returns the cache object.</p>
<p >For the usage of the <code>status</code> option, see <b>Status Tracking</b> below.</p>
<h2><a class="anchor" id="autotoc_md1701"></a>
&lt;tt&gt;get(key, { updateAgeOnGet, allowStale, status } = {}) =&gt; value&lt;/tt&gt;</h2>
<p >Return a value from the cache.</p>
<p >Will update the recency of the cache entry found.</p>
<p >If the key is not found, <code>get()</code> will return <code>undefined</code>. This can be confusing when setting values specifically to <code>undefined</code>, as in <code>cache.set(key, undefined)</code>. Use <code>cache.has()</code> to determine whether a key is present in the cache at all.</p>
<p >For the usage of the <code>status</code> option, see <b>Status Tracking</b> below.</p>
<h2><a class="anchor" id="autotoc_md1702"></a>
&lt;tt&gt;async fetch(key, options = {}) =&gt; Promise&lt;/tt&gt;</h2>
<p >The following options are supported:</p>
<ul>
<li><code>updateAgeOnGet</code></li>
<li><code>allowStale</code></li>
<li><code>size</code></li>
<li><code>sizeCalculation</code></li>
<li><code>ttl</code></li>
<li><code>noDisposeOnSet</code></li>
<li><code>forceRefresh</code></li>
<li><code>status</code> - See <b>Status Tracking</b> below.</li>
<li><code>signal</code> - AbortSignal can be used to cancel the <code>fetch()</code>. Note that the <code>signal</code> option provided to the <code>fetchMethod</code> is a different object, because it must also respond to internal cache state changes, but aborting this signal will abort the one passed to <code>fetchMethod</code> as well.</li>
<li><code>fetchContext</code> - sets the <code>context</code> option passed to the underlying <code>fetchMethod</code>.</li>
</ul>
<p >If the value is in the cache and not stale, then the returned Promise resolves to the value.</p>
<p >If not in the cache, or beyond its TTL staleness, then <code>fetchMethod(key, staleValue, { options, signal, context })</code> is called, and the value returned will be added to the cache once resolved.</p>
<p >If called with <code>allowStale</code>, and an asynchronous fetch is currently in progress to reload a stale value, then the former stale value will be returned.</p>
<p >If called with <code>forceRefresh</code>, then the cached item will be re-fetched, even if it is not stale. However, if <code>allowStale</code> is set, then the old value will still be returned. This is useful in cases where you want to force a reload of a cached value. If a background fetch is already in progress, then <code>forceRefresh</code> has no effect.</p>
<p >Multiple fetches for the same <code>key</code> will only call <code>fetchMethod</code> a single time, and all will be resolved when the value is resolved, even if different options are used.</p>
<p >If <code>fetchMethod</code> is not specified, then this is effectively an alias for <code>Promise.resolve(cache.get(key))</code>.</p>
<p >When the fetch method resolves to a value, if the fetch has not been aborted due to deletion, eviction, or being overwritten, then it is added to the cache using the options provided.</p>
<p >If the key is evicted or deleted before the <code>fetchMethod</code> resolves, then the AbortSignal passed to the <code>fetchMethod</code> will receive an <code>abort</code> event, and the promise returned by <code>fetch()</code> will reject with the reason for the abort.</p>
<p >If a <code>signal</code> is passed to the <code>fetch()</code> call, then aborting the signal will abort the fetch and cause the <code>fetch()</code> promise to reject with the reason provided.</p>
<h2><a class="anchor" id="autotoc_md1703"></a>
&lt;tt&gt;peek(key, { allowStale } = {}) =&gt; value&lt;/tt&gt;</h2>
<p >Like <code>get()</code> but doesn't update recency or delete stale items.</p>
<p >Returns <code>undefined</code> if the item is stale, unless <code>allowStale</code> is set either on the cache or in the options object.</p>
<h2><a class="anchor" id="autotoc_md1704"></a>
&lt;tt&gt;has(key, { updateAgeOnHas, status } = {}) =&gt; Boolean&lt;/tt&gt;</h2>
<p >Check if a key is in the cache, without updating the recency of use. Age is updated if <code>updateAgeOnHas</code> is set to <code>true</code> in either the options or the constructor.</p>
<p >Will return <code>false</code> if the item is stale, even though it is technically in the cache. The difference can be determined (if it matters) by using a <code>status</code> argument, and inspecting the <code>has</code> field.</p>
<p >For the usage of the <code>status</code> option, see <b>Status Tracking</b> below.</p>
<h2><a class="anchor" id="autotoc_md1705"></a>
&lt;tt&gt;delete(key)&lt;/tt&gt;</h2>
<p >Deletes a key out of the cache.</p>
<p >Returns <code>true</code> if the key was deleted, <code>false</code> otherwise.</p>
<h2><a class="anchor" id="autotoc_md1706"></a>
&lt;tt&gt;clear()&lt;/tt&gt;</h2>
<p >Clear the cache entirely, throwing away all values.</p>
<p >Deprecated alias: <code>reset()</code></p>
<h2><a class="anchor" id="autotoc_md1707"></a>
&lt;tt&gt;keys()&lt;/tt&gt;</h2>
<p >Return a generator yielding the keys in the cache, in order from most recently used to least recently used.</p>
<h2><a class="anchor" id="autotoc_md1708"></a>
&lt;tt&gt;rkeys()&lt;/tt&gt;</h2>
<p >Return a generator yielding the keys in the cache, in order from least recently used to most recently used.</p>
<h2><a class="anchor" id="autotoc_md1709"></a>
&lt;tt&gt;values()&lt;/tt&gt;</h2>
<p >Return a generator yielding the values in the cache, in order from most recently used to least recently used.</p>
<h2><a class="anchor" id="autotoc_md1710"></a>
&lt;tt&gt;rvalues()&lt;/tt&gt;</h2>
<p >Return a generator yielding the values in the cache, in order from least recently used to most recently used.</p>
<h2><a class="anchor" id="autotoc_md1711"></a>
&lt;tt&gt;entries()&lt;/tt&gt;</h2>
<p >Return a generator yielding <code>[key, value]</code> pairs, in order from most recently used to least recently used.</p>
<h2><a class="anchor" id="autotoc_md1712"></a>
&lt;tt&gt;rentries()&lt;/tt&gt;</h2>
<p >Return a generator yielding <code>[key, value]</code> pairs, in order from least recently used to most recently used.</p>
<h2><a class="anchor" id="autotoc_md1713"></a>
&lt;tt&gt;find(fn, [getOptions])&lt;/tt&gt;</h2>
<p >Find a value for which the supplied <code>fn</code> method returns a truthy value, similar to <code>Array.find()</code>.</p>
<p ><code>fn</code> is called as <code>fn(value, key, cache)</code>.</p>
<p >The optional <code>getOptions</code> are applied to the resulting <code>get()</code> of the item found.</p>
<h2><a class="anchor" id="autotoc_md1714"></a>
&lt;tt&gt;dump()&lt;/tt&gt;</h2>
<p >Return an array of <code>[key, entry]</code> objects which can be passed to <code>cache.load()</code></p>
<p >The <code>start</code> fields are calculated relative to a portable <code>Date.now()</code> timestamp, even if <code>performance.now()</code> is available.</p>
<p >Stale entries are always included in the <code>dump</code>, even if <code>allowStale</code> is false.</p>
<p >Note: this returns an actual array, not a generator, so it can be more easily passed around.</p>
<h2><a class="anchor" id="autotoc_md1715"></a>
&lt;tt&gt;load(entries)&lt;/tt&gt;</h2>
<p >Reset the cache and load in the items in <code>entries</code> in the order listed. Note that the shape of the resulting cache may be different if the same options are not used in both caches.</p>
<p >The <code>start</code> fields are assumed to be calculated relative to a portable <code>Date.now()</code> timestamp, even if <code>performance.now()</code> is available.</p>
<h2><a class="anchor" id="autotoc_md1716"></a>
&lt;tt&gt;purgeStale()&lt;/tt&gt;</h2>
<p >Delete any stale entries. Returns <code>true</code> if anything was removed, <code>false</code> otherwise.</p>
<p >Deprecated alias: <code>prune</code></p>
<h2><a class="anchor" id="autotoc_md1717"></a>
&lt;tt&gt;getRemainingTTL(key)&lt;/tt&gt;</h2>
<p >Return the number of ms left in the item's TTL. If item is not in cache, returns <code>0</code>. Returns <code>Infinity</code> if item is in cache without a defined TTL.</p>
<h2><a class="anchor" id="autotoc_md1718"></a>
&lt;tt&gt;forEach(fn, [thisp])&lt;/tt&gt;</h2>
<p >Call the <code>fn</code> function with each set of <code>fn(value, key, cache)</code> in the LRU cache, from most recent to least recently used.</p>
<p >Does not affect recency of use.</p>
<p >If <code>thisp</code> is provided, function will be called in the <code>this</code>-context of the provided object.</p>
<h2><a class="anchor" id="autotoc_md1719"></a>
&lt;tt&gt;rforEach(fn, [thisp])&lt;/tt&gt;</h2>
<p >Same as <code>cache.forEach(fn, thisp)</code>, but in order from least recently used to most recently used.</p>
<h2><a class="anchor" id="autotoc_md1720"></a>
&lt;tt&gt;pop()&lt;/tt&gt;</h2>
<p >Evict the least recently used item, returning its value.</p>
<p >Returns <code>undefined</code> if cache is empty.</p>
<h2><a class="anchor" id="autotoc_md1721"></a>
Internal Methods and Properties</h2>
<p >In order to optimize performance as much as possible, "private" members and methods are exposed on the object as normal properties, rather than being accessed via Symbols, private members, or closure variables.</p>
<p ><b>Do not use or rely on these.</b> They will change or be removed without notice. They will cause undefined behavior if used inappropriately. There is no need or reason to ever call them directly.</p>
<p >This documentation is here so that it is especially clear that this not "undocumented" because someone forgot; it <em>is</em> documented, and the documentation is telling you not to do it.</p>
<p ><b>Do not report bugs that stem from using these properties.</b> They will be ignored.</p>
<ul>
<li><code>initializeTTLTracking()</code> Set up the cache for tracking TTLs</li>
<li><code>updateItemAge(index)</code> Called when an item age is updated, by internal ID</li>
<li><code>setItemTTL(index)</code> Called when an item ttl is updated, by internal ID</li>
<li><code>isStale(index)</code> Called to check an item's staleness, by internal ID</li>
<li><code>initializeSizeTracking()</code> Set up the cache for tracking item size. Called automatically when a size is specified.</li>
<li><code>removeItemSize(index)</code> Updates the internal size calculation when an item is removed or modified, by internal ID</li>
<li><code>addItemSize(index)</code> Updates the internal size calculation when an item is added or modified, by internal ID</li>
<li><code>indexes()</code> An iterator over the non-stale internal IDs, from most recently to least recently used.</li>
<li><code>rindexes()</code> An iterator over the non-stale internal IDs, from least recently to most recently used.</li>
<li><code>newIndex()</code> Create a new internal ID, either reusing a deleted ID, evicting the least recently used ID, or walking to the end of the allotted space.</li>
<li><code>evict()</code> Evict the least recently used internal ID, returning its ID. Does not do any bounds checking.</li>
<li><code>connect(p, n)</code> Connect the <code>p</code> and <code>n</code> internal IDs in the linked list.</li>
<li><code>moveToTail(index)</code> Move the specified internal ID to the most recently used position.</li>
<li><code>keyMap</code> Map of keys to internal IDs</li>
<li><code>keyList</code> List of keys by internal ID</li>
<li><code>valList</code> List of values by internal ID</li>
<li><code>sizes</code> List of calculated sizes by internal ID</li>
<li><code>ttls</code> List of TTL values by internal ID</li>
<li><code>starts</code> List of start time values by internal ID</li>
<li><code>next</code> Array of "next" pointers by internal ID</li>
<li><code>prev</code> Array of "previous" pointers by internal ID</li>
<li><code>head</code> Internal ID of least recently used item</li>
<li><code>tail</code> Internal ID of most recently used item</li>
<li><code>free</code> Stack of deleted internal IDs</li>
</ul>
<h1><a class="anchor" id="autotoc_md1722"></a>
Status Tracking</h1>
<p >Occasionally, it may be useful to track the internal behavior of the cache, particularly for logging, debugging, or for behavior within the <code>fetchMethod</code>. To do this, you can pass a <code>status</code> object to the <code>get()</code>, <code>set()</code>, <code>has()</code>, and <code>fetch()</code> methods.</p>
<p >The <code>status</code> option should be a plain JavaScript object.</p>
<p >The following fields will be set appropriately:</p>
<div class="fragment"><div class="line">interface Status&lt;V&gt; {</div>
<div class="line">  /**</div>
<div class="line">   * The status of a set() operation.</div>
<div class="line">   *</div>
<div class="line">   * - add: the item was not found in the cache, and was added</div>
<div class="line">   * - update: the item was in the cache, with the same value provided</div>
<div class="line">   * - replace: the item was in the cache, and replaced</div>
<div class="line">   * - miss: the item was not added to the cache for some reason</div>
<div class="line">   */</div>
<div class="line">  set?: &#39;add&#39; | &#39;update&#39; | &#39;replace&#39; | &#39;miss&#39;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * the ttl stored for the item, or undefined if ttls are not used.</div>
<div class="line">   */</div>
<div class="line">  ttl?: LRUMilliseconds</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * the start time for the item, or undefined if ttls are not used.</div>
<div class="line">   */</div>
<div class="line">  start?: LRUMilliseconds</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The timestamp used for TTL calculation</div>
<div class="line">   */</div>
<div class="line">  now?: LRUMilliseconds</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * the remaining ttl for the item, or undefined if ttls are not used.</div>
<div class="line">   */</div>
<div class="line">  remainingTTL?: LRUMilliseconds</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The calculated size for the item, if sizes are used.</div>
<div class="line">   */</div>
<div class="line">  size?: LRUSize</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * A flag indicating that the item was not stored, due to exceeding the</div>
<div class="line">   * {@link maxEntrySize}</div>
<div class="line">   */</div>
<div class="line">  maxEntrySizeExceeded?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The old value, specified in the case of `set:&#39;update&#39;` or</div>
<div class="line">   * `set:&#39;replace&#39;`</div>
<div class="line">   */</div>
<div class="line">  oldValue?: V</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The results of a {@link has} operation</div>
<div class="line">   *</div>
<div class="line">   * - hit: the item was found in the cache</div>
<div class="line">   * - stale: the item was found in the cache, but is stale</div>
<div class="line">   * - miss: the item was not found in the cache</div>
<div class="line">   */</div>
<div class="line">  has?: &#39;hit&#39; | &#39;stale&#39; | &#39;miss&#39;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The status of a {@link fetch} operation.</div>
<div class="line">   * Note that this can change as the underlying fetch() moves through</div>
<div class="line">   * various states.</div>
<div class="line">   *</div>
<div class="line">   * - inflight: there is another fetch() for this key which is in process</div>
<div class="line">   * - get: there is no fetchMethod, so {@link get} was called.</div>
<div class="line">   * - miss: the item is not in cache, and will be fetched.</div>
<div class="line">   * - hit: the item is in the cache, and was resolved immediately.</div>
<div class="line">   * - stale: the item is in the cache, but stale.</div>
<div class="line">   * - refresh: the item is in the cache, and not stale, but</div>
<div class="line">   *   {@link forceRefresh} was specified.</div>
<div class="line">   */</div>
<div class="line">  fetch?: &#39;get&#39; | &#39;inflight&#39; | &#39;miss&#39; | &#39;hit&#39; | &#39;stale&#39; | &#39;refresh&#39;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The {@link fetchMethod} was called</div>
<div class="line">   */</div>
<div class="line">  fetchDispatched?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The cached value was updated after a successful call to fetchMethod</div>
<div class="line">   */</div>
<div class="line">  fetchUpdated?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The reason for a fetch() rejection.  Either the error raised by the</div>
<div class="line">   * {@link fetchMethod}, or the reason for an AbortSignal.</div>
<div class="line">   */</div>
<div class="line">  fetchError?: Error</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The fetch received an abort signal</div>
<div class="line">   */</div>
<div class="line">  fetchAborted?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The abort signal received was ignored, and the fetch was allowed to</div>
<div class="line">   * continue.</div>
<div class="line">   */</div>
<div class="line">  fetchAbortIgnored?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The fetchMethod promise resolved successfully</div>
<div class="line">   */</div>
<div class="line">  fetchResolved?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The results of the fetchMethod promise were stored in the cache</div>
<div class="line">   */</div>
<div class="line">  fetchUpdated?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The fetchMethod promise was rejected</div>
<div class="line">   */</div>
<div class="line">  fetchRejected?: true</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * The status of a {@link get} operation.</div>
<div class="line">   *</div>
<div class="line">   * - fetching: The item is currently being fetched.  If a previous value is</div>
<div class="line">   *   present and allowed, that will be returned.</div>
<div class="line">   * - stale: The item is in the cache, and is stale.</div>
<div class="line">   * - hit: the item is in the cache</div>
<div class="line">   * - miss: the item is not in the cache</div>
<div class="line">   */</div>
<div class="line">  get?: &#39;stale&#39; | &#39;hit&#39; | &#39;miss&#39;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * A fetch or get operation returned a stale value.</div>
<div class="line">   */</div>
<div class="line">  returnedStale?: true</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1723"></a>
Storage Bounds Safety</h1>
<p >This implementation aims to be as flexible as possible, within the limits of safe memory consumption and optimal performance.</p>
<p >At initial object creation, storage is allocated for <code>max</code> items. If <code>max</code> is set to zero, then some performance is lost, and item count is unbounded. Either <code>maxSize</code> or <code>ttl</code> <em>must</em> be set if <code>max</code> is not specified.</p>
<p >If <code>maxSize</code> is set, then this creates a safe limit on the maximum storage consumed, but without the performance benefits of pre-allocation. When <code>maxSize</code> is set, every item <em>must</em> provide a size, either via the <code>sizeCalculation</code> method provided to the constructor, or via a <code>size</code> or <code>sizeCalculation</code> option provided to <code>cache.set()</code>. The size of every item <em>must</em> be a positive integer.</p>
<p >If neither <code>max</code> nor <code>maxSize</code> are set, then <code>ttl</code> tracking must be enabled. Note that, even when tracking item <code>ttl</code>, items are <em>not</em> preemptively deleted when they become stale, unless <code>ttlAutopurge</code> is enabled. Instead, they are only purged the next time the key is requested. Thus, if <code>ttlAutopurge</code>, <code>max</code>, and <code>maxSize</code> are all not set, then the cache will potentially grow unbounded.</p>
<p >In this case, a warning is printed to standard error. Future versions may require the use of <code>ttlAutopurge</code> if <code>max</code> and <code>maxSize</code> are not specified.</p>
<p >If you truly wish to use a cache that is bound <em>only</em> by TTL expiration, consider using a <code>Map</code> object, and calling <code>setTimeout</code> to delete entries when they expire. It will perform much better than an LRU cache.</p>
<p >Here is an implementation you may use, under the same <a href="./LICENSE">license</a> as this package:</p>
<div class="fragment"><div class="line">// a storage-unbounded ttl cache that is not an lru-cache</div>
<div class="line">const cache = {</div>
<div class="line">  data: new Map(),</div>
<div class="line">  timers: new Map(),</div>
<div class="line">  set: (k, v, ttl) =&gt; {</div>
<div class="line">    if (cache.timers.has(k)) {</div>
<div class="line">      clearTimeout(cache.timers.get(k))</div>
<div class="line">    }</div>
<div class="line">    cache.timers.set(</div>
<div class="line">      k,</div>
<div class="line">      setTimeout(() =&gt; cache.delete(k), ttl)</div>
<div class="line">    )</div>
<div class="line">    cache.data.set(k, v)</div>
<div class="line">  },</div>
<div class="line">  get: k =&gt; cache.data.get(k),</div>
<div class="line">  has: k =&gt; cache.data.has(k),</div>
<div class="line">  delete: k =&gt; {</div>
<div class="line">    if (cache.timers.has(k)) {</div>
<div class="line">      clearTimeout(cache.timers.get(k))</div>
<div class="line">    }</div>
<div class="line">    cache.timers.delete(k)</div>
<div class="line">    return cache.data.delete(k)</div>
<div class="line">  },</div>
<div class="line">  clear: () =&gt; {</div>
<div class="line">    cache.data.clear()</div>
<div class="line">    for (const v of cache.timers.values()) {</div>
<div class="line">      clearTimeout(v)</div>
<div class="line">    }</div>
<div class="line">    cache.timers.clear()</div>
<div class="line">  },</div>
<div class="line">}</div>
</div><!-- fragment --><p >If that isn't to your liking, check out <a href="http://npm.im/@isaacs/ttlcache">@isaacs/ttlcache</a>.</p>
<h1><a class="anchor" id="autotoc_md1724"></a>
Performance</h1>
<p >As of January 2022, version 7 of this library is one of the most performant LRU cache implementations in JavaScript.</p>
<p >Benchmarks can be extremely difficult to get right. In particular, the performance of set/get/delete operations on objects will vary <em>wildly</em> depending on the type of key used. V8 is highly optimized for objects with keys that are short strings, especially integer numeric strings. Thus any benchmark which tests <em>solely</em> using numbers as keys will tend to find that an object-based approach performs the best.</p>
<p >Note that coercing <em>anything</em> to strings to use as object keys is unsafe, unless you can be 100% certain that no other type of value will be used. For example:</p>
<div class="fragment"><div class="line">const myCache = {}</div>
<div class="line">const set = (k, v) =&gt; (myCache[k] = v)</div>
<div class="line">const get = k =&gt; myCache[k]</div>
<div class="line"> </div>
<div class="line">set({}, &#39;please hang onto this for me&#39;)</div>
<div class="line">set(&#39;[object Object]&#39;, &#39;oopsie&#39;)</div>
</div><!-- fragment --><p >Also beware of "Just So" stories regarding performance. Garbage collection of large (especially: deep) object graphs can be incredibly costly, with several "tipping points" where it increases exponentially. As a result, putting that off until later can make it much worse, and less predictable. If a library performs well, but only in a scenario where the object graph is kept shallow, then that won't help you if you are using large objects as keys.</p>
<p >In general, when attempting to use a library to improve performance (such as a cache like this one), it's best to choose an option that will perform well in the sorts of scenarios where you'll actually use it.</p>
<p >This library is optimized for repeated gets and minimizing eviction time, since that is the expected need of a LRU. Set operations are somewhat slower on average than a few other options, in part because of that optimization. It is assumed that you'll be caching some costly operation, ideally as rarely as possible, so optimizing set over get would be unwise.</p>
<p >If performance matters to you:</p>
<ol type="1">
<li>If it's at all possible to use small integer values as keys, and you can guarantee that no other types of values will be used as keys, then do that, and use a cache such as <a href="https://npmjs.com/package/lru-fast">lru-fast</a>, or <a href="https://yomguithereal.github.io/mnemonist/lru-cache">mnemonist's LRUCache</a> which uses an Object as its data store.</li>
<li>Failing that, if at all possible, use short non-numeric strings (ie, less than 256 characters) as your keys, and use <a href="https://yomguithereal.github.io/mnemonist/lru-cache">mnemonist's LRUCache</a>.</li>
<li>If the types of your keys will be long strings, strings that look like floats, <code>null</code>, objects, or some mix of types, or if you aren't sure, then this library will work well for you.</li>
<li>Do not use a <code>dispose</code> function, size tracking, or especially ttl behavior, unless absolutely needed. These features are convenient, and necessary in some use cases, and every attempt has been made to make the performance impact minimal, but it isn't nothing.</li>
</ol>
<h1><a class="anchor" id="autotoc_md1725"></a>
Breaking Changes in Version 7</h1>
<p >This library changed to a different algorithm and internal data structure in version 7, yielding significantly better performance, albeit with some subtle changes as a result.</p>
<p >If you were relying on the internals of LRUCache in version 6 or before, it probably will not work in version 7 and above.</p>
<p >For more info, see the change log. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
